        -:    0:Source:spex_dppu2.c
        -:    0:Graph:spex_dppu2.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_CHOLMOD/spex_dppu2.c: perform diagonal permutation pivot update
        -:    3://------------------------------------------------------------------------------
        -:    4:
        -:    5:// SPEX_CHOLMOD: (c) 2020-2021, Jinhao Chen, Timothy A. Davis, Erick
        -:    6:// Moreno-Centeno, Texas A&M University.  All Rights Reserved.  See
        -:    7:// SPEX_CHOLMOD/License for the license.
        -:    8:
        -:    9://------------------------------------------------------------------------------
        -:   10:
        -:   11:// Purpose: This function is called to perform diagonal permutation pivot update
        -:   12:// when the submatrix (formed by columns k to ks) has the following
        -:   13:// pattern
        -:   14://       . . . . .  (row 1)
        -:   15://       . . . . .  (rows 2 to k-1)
        -:   16://       x . . . .  (row k)
        -:   17://       0 x . . 0  (row k+1)
        -:   18://       0 . x . 0  ( .... )
        -:   19://       0 . . x 0  (row ks-1)
        -:   20://       0 0 0 0 x  (row ks)
        -:   21://       0 . . . .  (row ks+1 to n-1)
        -:   22://       0 . . . .  (row n)
        -:   23:// This function will swap rows and columns k and ks in L and U. Noted that the
        -:   24:// rows of L and columns of U are permuted implicitly via the permutation
        -:   25:// matrices based on P and Q.
        -:   26:
        -:   27:#define SPEX_FREE_ALL                \
        -:   28:    SPEX_MPZ_CLEAR(Lksk);            \
        -:   29:    SPEX_MPQ_CLEAR(one);             \
        -:   30:    SPEX_MPQ_CLEAR(pending_scale);
        -:   31:
        -:   32:#include "spex_internal.h"
        -:   33:
    #####:   34:SPEX_info spex_dppu2
        -:   35:(
        -:   36:    SPEX_matrix *L,  // matrix L
        -:   37:    SPEX_matrix *U,  // matrix U
        -:   38:    mpq_t *S,        // array of size 3*n that stores pending scales
        -:   39:    mpz_t *d,        // array of size n that stores the unscaled pivot
        -:   40:    mpz_t *sd,       // array of size n that stores the scaled pivot
        -:   41:    spex_scattered_vector *Lk_dense_col,// scattered column k of L
        -:   42:    spex_scattered_vector *Uk_dense_row,// scattered column k of U
        -:   43:    const mpq_t vk_scale,// scale factor for newly inserted column vk, which
        -:   44:                     // should be in col k of L in the last iteration when used.
        -:   45:    int64_t *jnext,  // the index of first off-diag entry in row k of U
        -:   46:    int64_t *h,      // allocated vector that can be used for history vector.
        -:   47:                     // All entries are maintained to be >= -1
        -:   48:    int64_t *Q,      // column permutation
        -:   49:    int64_t *Q_inv,  // inverse of column permutation
        -:   50:    int64_t *P,      // row permutation
        -:   51:    int64_t *P_inv,  // inverse of row permutation
        -:   52:    int64_t *Ldiag,  // L(k,k) can be found as L->v[k]->x[Ldiag[k]]
        -:   53:    const int64_t *Uci,// the row index for col-wise nnz pattern of U
        -:   54:    const int64_t *Ucp,// col pointers for col-wise nnz pattern of U
        -:   55:    const int64_t *Ucx,// the value of k-th entry is found as
        -:   56:                       // U->v[Uci[k]]->x[Ucx[k]]
        -:   57:    const int64_t k,   // current column index 0 <= k < n
        -:   58:    const int64_t ks   // index of the diagonal to be swapped with, [0,n)
        -:   59:)
        -:   60:{
        -:   61:    // initialize workspace
        -:   62:    SPEX_info info;
        -:   63:    int sgn;
    #####:   64:    int64_t tmpi, j, n = U->n, tmp_ks = SPEX_MIN(ks, n-1);
        -:   65:    SPEX_vector *v;
        -:   66:
        -:   67:    mpq_t pending_scale, one;
    #####:   68:    SPEX_MPQ_SET_NULL(pending_scale); SPEX_MPQ_SET_NULL(one);
    #####:   69:    mpz_t Lksk; SPEX_MPZ_SET_NULL(Lksk);
    #####:   70:    SPEX_CHECK(SPEX_mpq_init(pending_scale));
    #####:   71:    SPEX_CHECK(SPEX_mpq_init(one));
    #####:   72:    SPEX_CHECK(SPEX_mpq_set_ui(one, 1, 1));
    #####:   73:    SPEX_CHECK(SPEX_mpz_init(Lksk));
        -:   74:
    #####:   75:    if (ks == n)
        -:   76:    {
        -:   77:        //----------------------------------------------------------------------
        -:   78:        // backtrack U(n-1,n-1)
        -:   79:        //----------------------------------------------------------------------
    #####:   80:        if (k > 0)
        -:   81:        {
    #####:   82:            SPEX_CHECK(SPEX_mpz_mul(U->v[n-1]->x[0], sd[n-1], sd[k-1]));
    #####:   83:            SPEX_CHECK(SPEX_mpz_divexact(U->v[n-1]->x[0],
        -:   84:                                         U->v[n-1]->x[0], sd[n-2]));
        -:   85:        }
        -:   86:        else
        -:   87:        {
    #####:   88:            SPEX_CHECK(SPEX_mpz_divexact(U->v[n-1]->x[0], sd[n-1], sd[n-2]));
        -:   89:        }
        -:   90:
        -:   91:        //----------------------------------------------------------------------
        -:   92:        // update entries in frames between k and n-1
        -:   93:        //----------------------------------------------------------------------        // since the value in Uk_dense_row[Q[k]] will not be used, we use it to
        -:   94:        // hold the original value of sd[k] before swapping columns and rows of
        -:   95:        // k and n-1. Then we set sd[k] to d[k] with pending scaling factor
        -:   96:        // applied
    #####:   97:        SPEX_CHECK(SPEX_mpz_swap(Uk_dense_row->x[Q[k]], sd[k]));
    #####:   98:        SPEX_CHECK(SPEX_mpz_divexact(sd[k],  d[k], SPEX_MPQ_DEN(vk_scale)));
    #####:   99:        SPEX_CHECK(SPEX_mpz_mul     (sd[k], sd[k], SPEX_MPQ_NUM(vk_scale)));
        -:  100:
    #####:  101:        if (n > k+2) // n-1 > k+1
        -:  102:        {
        -:  103:            // pending_scale = sd(k)/Uk_dense_row[Q[k]]
    #####:  104:            SPEX_CHECK(SPEX_mpq_set_z(pending_scale, sd[k]));
    #####:  105:            SPEX_CHECK(SPEX_mpq_set_den(pending_scale, Uk_dense_row->x[Q[k]]));
    #####:  106:            SPEX_CHECK(SPEX_mpq_canonicalize(pending_scale));
        -:  107:
        -:  108:            // scale entries in frames k+1:n-2
    #####:  109:            for (j = k+1; j < n-1; j++)
        -:  110:            {
        -:  111:                // S(3,j) = S(3,j)*pending_scale;
    #####:  112:                SPEX_CHECK(SPEX_mpq_mul(SPEX_2D(S, 3, j),
        -:  113:                                        SPEX_2D(S, 3, j), pending_scale));
        -:  114:                // sd(j) = sd(j)*pending_scale;
    #####:  115:                SPEX_CHECK(SPEX_mpz_divexact(sd[j],
        -:  116:                                        sd[j], SPEX_MPQ_DEN(pending_scale)));
    #####:  117:                SPEX_CHECK(SPEX_mpz_mul(sd[j],
        -:  118:                                        sd[j], SPEX_MPQ_NUM(pending_scale)));
        -:  119:            }
        -:  120:        }
        -:  121:
        -:  122:        //----------------------------------------------------------------------
        -:  123:        // swap rows and columns k and n-1 of L and U
        -:  124:        //----------------------------------------------------------------------
        -:  125:        // swap rows k and n-1 of U           % O(1) time
    #####:  126:        v = U->v[k];       U->v[k] = U->v[n-1];    U->v[n-1] = v;
        -:  127:
        -:  128:        // update row permutation to swap rows of L implicitly
    #####:  129:        tmpi = P[k];    P[k] = P[n-1];          P[n-1] = tmpi;
    #####:  130:        P_inv[P[k]] = k;   P_inv[tmpi] = n-1;
        -:  131:
        -:  132:        // U(k,Q(k)) and S(:,k) will be updated after calling this function
        -:  133:        // S(:,n-1) = [1;1;S(3,k)]; since S(:,k) and S(:,n-1) not swapped
    #####:  134:        SPEX_CHECK(SPEX_mpq_swap(SPEX_2D(S, 3, n-1), SPEX_2D(S, 3, k))); 
    #####:  135:        SPEX_CHECK(SPEX_mpq_set_ui(SPEX_2D(S, 1, n-1), 1, 1));
    #####:  136:        SPEX_CHECK(SPEX_mpq_set_ui(SPEX_2D(S, 2, n-1), 1, 1));
        -:  137:    }
        -:  138:    else
        -:  139:    {
        -:  140:        //----------------------------------------------------------------------
        -:  141:        // perform backtracking for frame ks
        -:  142:        //----------------------------------------------------------------------
        -:  143:        // find the scale for backtracking
    #####:  144:        if (k == 0)
        -:  145:        {
        -:  146:            // pending_scale = 1/sd(ks-1)
    #####:  147:            SPEX_CHECK(SPEX_mpq_set_ui(pending_scale, 1, 1));
        -:  148:        }
        -:  149:        else
        -:  150:        {
        -:  151:            // pending_scale = sd(k-1)/sd(ks-1)
    #####:  152:            SPEX_CHECK(SPEX_mpq_set_z(pending_scale, sd[k-1]));
        -:  153:        }
    #####:  154:        SPEX_CHECK(SPEX_mpq_set_den(pending_scale, sd[tmp_ks-1]));
        -:  155:        // remove common factor in mpq_den and mpq_num
    #####:  156:        SPEX_CHECK(SPEX_mpq_canonicalize(pending_scale));
        -:  157:
        -:  158:        // S(3,ks) = pending_scale*S(3,ks)
    #####:  159:        SPEX_CHECK(SPEX_mpq_mul(SPEX_2D(S, 3, tmp_ks),
        -:  160:                                SPEX_2D(S, 3, tmp_ks), pending_scale));
        -:  161:        // sd(ks) = sd(ks)*pending_scale
    #####:  162:        SPEX_CHECK(SPEX_mpz_divexact(sd[tmp_ks],
        -:  163:                                sd[tmp_ks], SPEX_MPQ_DEN(pending_scale)));
    #####:  164:        SPEX_CHECK(SPEX_mpz_mul(sd[tmp_ks],
        -:  165:                                sd[tmp_ks], SPEX_MPQ_NUM(pending_scale)));
        -:  166:
        -:  167:        //----------------------------------------------------------------------
        -:  168:        // swap rows and columns k and ks of L and U
        -:  169:        //----------------------------------------------------------------------
        -:  170:        // swap entries in d, sd and S
    #####:  171:        SPEX_CHECK(SPEX_mpz_swap(sd[k], sd[tmp_ks]));
    #####:  172:        SPEX_CHECK(SPEX_mpz_swap(d[k],  d[tmp_ks]));
    #####:  173:        SPEX_CHECK(SPEX_mpq_swap(SPEX_2D(S, 1, tmp_ks), SPEX_2D(S, 1, k)));
    #####:  174:        SPEX_CHECK(SPEX_mpq_swap(SPEX_2D(S, 2, tmp_ks), SPEX_2D(S, 2, k)));
    #####:  175:        SPEX_CHECK(SPEX_mpq_swap(SPEX_2D(S, 3, tmp_ks), SPEX_2D(S, 3, k)));
        -:  176:
        -:  177:        // swap columns k and ks of L        % O(1) time
    #####:  178:        v = L->v[k];       L->v[k] = L->v[tmp_ks];    L->v[tmp_ks] = v;
        -:  179:        // swap rows k and ks of U           % O(1) time
    #####:  180:        v = U->v[k];       U->v[k] = U->v[tmp_ks];    U->v[tmp_ks] = v;
        -:  181:
        -:  182:        // update row/col permutation to swap rows of L and cols of U implicitly
    #####:  183:        tmpi = Q[k];       Q[k] = Q[tmp_ks];          Q[tmp_ks] = tmpi;
    #####:  184:        Q_inv[Q[k]] = k;   Q_inv[tmpi] = tmp_ks;
    #####:  185:        tmpi = P[k];       P[k] = P[tmp_ks];          P[tmp_ks] = tmpi;
    #####:  186:        P_inv[P[k]] = k;   P_inv[tmpi] = tmp_ks;
        -:  187:
        -:  188:        // update Ldiag[k] = Ldiag[ks]
    #####:  189:        Ldiag[k] = Ldiag[tmp_ks];
        -:  190:
        -:  191:        //----------------------------------------------------------------------
        -:  192:        // update entries in frames between k and ks
        -:  193:        //----------------------------------------------------------------------
    #####:  194:        if (tmp_ks > k+1)
        -:  195:        {
        -:  196:            // get the scale for entries between frames k and ks % O(1) time 
        -:  197:            // pending_scale = sd(k)/sd (ks); 
    #####:  198:            SPEX_CHECK(SPEX_mpq_set_z(pending_scale, sd[k])); 
    #####:  199:            SPEX_CHECK(SPEX_mpq_set_den(pending_scale, sd[tmp_ks])); 
    #####:  200:            SPEX_CHECK(SPEX_mpq_canonicalize(pending_scale));
        -:  201:            // scale entries in frames k+1:ks-1
    #####:  202:            for (j = k+1; j < tmp_ks; j++)
        -:  203:            {
        -:  204:                // S(3,j) = S(3,j)*pending_scale;
    #####:  205:                SPEX_CHECK(SPEX_mpq_mul(SPEX_2D(S, 3, j),
        -:  206:                                        SPEX_2D(S, 3, j), pending_scale));
        -:  207:                // sd(j) = sd(j)*pending_scale;
    #####:  208:                SPEX_CHECK(SPEX_mpz_divexact(sd[j],
        -:  209:                                        sd[j], SPEX_MPQ_DEN(pending_scale)));
    #####:  210:                SPEX_CHECK(SPEX_mpz_mul(sd[j],
        -:  211:                                        sd[j], SPEX_MPQ_NUM(pending_scale)));
        -:  212:            }
        -:  213:        }
        -:  214:    }
        -:  215:
        -:  216:    //--------------------------------------------------------------------------
        -:  217:    // perform IPGE for row ks, skip IPGE for column since it is all zero
        -:  218:    //--------------------------------------------------------------------------
    #####:  219:    int64_t pks, cks, last_nz_b4_ks = k-1;
        -:  220:    // initialize history vector h
    #####:  221:    for (pks = 0; pks < Uk_dense_row->nz; pks++)
        -:  222:    {
    #####:  223:        cks = Uk_dense_row->i[pks];
        -:  224:        // Lk_dense_col or Uk_dense_row are initialized with no explicit zero
        -:  225:        // for column/row 0 (may contain explicit zero for column/row j>0).  And
        -:  226:        // entries in h are maintained to be >= -1. Therefore, with such
        -:  227:        // initialization, entry with h > -1 is clearly not in nnz pattern and
        -:  228:        // any entry in the nnz pattern with h = -1 must be nonzero.  In all,
        -:  229:        // any explicit zero with h >= -1 must not be in the nnz pattern.
        -:  230:        //
        -:  231:        // REMARK:
        -:  232:        // This is useful only for IPGE update, or when there is possibility of
        -:  233:        // fillin.
    #####:  234:        h[cks] = SPEX_FLIP(k-1);
        -:  235:    }
    #####:  236:    for (j = k; j < tmp_ks; j++)
        -:  237:    {
    #####:  238:        if (ks == n && j == k)
        -:  239:        {
        -:  240:            // find the pointer to the entry L(P[ks],k), there are only two
        -:  241:            // entries in L->v[k]
    #####:  242:            pks = (P[L->v[k]->i[0]] == tmp_ks) ? 0 : 1;
    #####:  243:            SPEX_CHECK(SPEX_mpz_sgn(&sgn, L->v[k]->x[pks]));
    #####:  244:            if (sgn == 0) { continue; }
        -:  245:
        -:  246:            // only need to perform IPGE for U(ks, Q(ks)) since there is only
        -:  247:            // one off-diagonal nnz in row k of U, which is U(k,Q(ks))
        -:  248:            // U(ks,Q(ks)) = (U(ks, Q(ks))*d[k]-
        -:  249:            //                                     vk(P[ks])*U(k,Q(ks)))/sd[k-1]
    #####:  250:            SPEX_CHECK(SPEX_mpz_mul(Uk_dense_row->x[Q[tmp_ks]],
        -:  251:                                    Uk_dense_row->x[Q[tmp_ks]], d[k]));
    #####:  252:            SPEX_CHECK(SPEX_mpz_addmul(Uk_dense_row->x[Q[tmp_ks]],
        -:  253:                                    U->v[k]->x[0], L->v[k]->x[pks]));
    #####:  254:            if (k > 0)
        -:  255:            {
    #####:  256:                SPEX_CHECK(SPEX_mpz_divexact(Uk_dense_row->x[Q[tmp_ks]],
        -:  257:                                    Uk_dense_row->x[Q[tmp_ks]], sd[k-1]));
        -:  258:            }
    #####:  259:            SPEX_CHECK(SPEX_mpq_mul(SPEX_2D(S, 3, tmp_ks),
        -:  260:                                    SPEX_2D(S, 3, tmp_ks), vk_scale));
        -:  261:
        -:  262:            // update history vector
    #####:  263:            h[Q[tmp_ks]] = SPEX_FLIP(k);
    #####:  264:            continue;
        -:  265:        }
        -:  266:        else
        -:  267:        {
    #####:  268:            SPEX_CHECK(SPEX_mpz_sgn(&sgn, Uk_dense_row->x[Q[j]]));
        -:  269:        }
        -:  270:        // skip if U(ks, Q[j]) == 0
    #####:  271:        if (sgn == 0) { continue; }
        -:  272:
        -:  273:        // perform j-th IPGE update for U(ks,:)
    #####:  274:        SPEX_CHECK(spex_ipge(Uk_dense_row, SPEX_2D(S, 3, tmp_ks), h, NULL,
        -:  275:            U->v[j], Q, Q_inv, (const mpz_t*)sd, SPEX_2D(S, 2, j),
        -:  276:            SPEX_2D(S, 3, j), Ucx[Ucp[Q[j]+1]-1], j));
        -:  277:        // update last_nz_b4_ks
    #####:  278:        last_nz_b4_ks = j;
        -:  279:
        -:  280:        // insert new entry L(P(ks), j) to L and swap its value with U(ks, Q(j))
    #####:  281:        SPEX_CHECK(spex_insert_new_entry(Uk_dense_row->x[Q[j]], L->v[j],
        -:  282:            SPEX_2D(S, 1, j), U->v[j], SPEX_2D(S, 2, j), SPEX_2D(S, 3, j), d[j],
        -:  283:            P[tmp_ks], Ucx[Ucp[Q[j]+1]-1], one));
        -:  284:    }
        -:  285:
        -:  286:    // There must be at least one nonzero in U(ks, Q(k:ks-1)) for this case.
        -:  287:    // Otherwise, this will be handled by spex_dppu1(...). Therefore,
        -:  288:    // last_nz_b4_ks must have updated at least once and be greater than k-1
        -:  289:    ASSERT(last_nz_b4_ks > k-1);
        -:  290:
    #####:  291:    if (ks == n)
        -:  292:    {
    #####:  293:        h[Q[k]]  = SPEX_FLIP(h[Q[k]]);
    #####:  294:        h[Q[tmp_ks]] = SPEX_FLIP(h[Q[tmp_ks]]);
    #####:  295:        last_nz_b4_ks = h[Q[tmp_ks]];
        -:  296:    }
        -:  297:    else
        -:  298:    {
        -:  299:        // perform history update up to (last_nz_b4_ks)-th IPGE iteration
        -:  300:        // and remove zero from row ks of U
    #####:  301:        pks = 0;
    #####:  302:        *jnext = n;
    #####:  303:        while (pks < Uk_dense_row->nz)
        -:  304:        {
        -:  305:            // column index in row ks of U
    #####:  306:            cks = Uk_dense_row->i[pks];
    #####:  307:            h[cks] = SPEX_FLIP(h[cks]);
    #####:  308:            SPEX_CHECK(SPEX_mpz_sgn(&sgn, Uk_dense_row->x[cks]));
    #####:  309:            if (sgn == 0) {continue;}
        -:  310:
    #####:  311:            if (h[cks] < last_nz_b4_ks) // require history update
        -:  312:            {
        -:  313:                // U(ks, Q(k:ks-1)) were set to 0 but remained in nnz pattern
    #####:  314:                if (Q_inv[cks] < tmp_ks)
        -:  315:                {
        -:  316:                    // move the column index of last nonzero to current position
    #####:  317:                    Uk_dense_row->nz--;
    #####:  318:                    Uk_dense_row->i[pks] = Uk_dense_row->i[Uk_dense_row->nz];
    #####:  319:                    continue;
        -:  320:                }
    #####:  321:                else if (Q_inv[cks] > tmp_ks && Q_inv[cks] < *jnext)
        -:  322:                {
        -:  323:                    // update the index of next off-diagonal nnz entry
    #####:  324:                    *jnext = Q_inv[cks];
        -:  325:                }
        -:  326:
        -:  327:                // U(ks,cks) = (U(ks,cks)*sd(last_nz_b4_ks))/sd(h[cks]);
    #####:  328:                SPEX_CHECK(SPEX_mpz_mul(Uk_dense_row->x[cks],
        -:  329:                                      Uk_dense_row->x[cks], sd[last_nz_b4_ks]));
    #####:  330:                if (h[cks] > 0)
        -:  331:                {
    #####:  332:                    SPEX_CHECK(SPEX_mpz_divexact(Uk_dense_row->x[cks],
        -:  333:                                     Uk_dense_row->x[cks], sd[h[cks]]));
        -:  334:                }
        -:  335:            }
    #####:  336:            pks++;
        -:  337:        }
        -:  338:    }
        -:  339:
        -:  340:    // update S(3,ks)= S(3,ks)*sd(ks-1)/sd(last_nz_b4_ks)
    #####:  341:    if (last_nz_b4_ks != tmp_ks-1)
        -:  342:    {
    #####:  343:        SPEX_CHECK(SPEX_mpq_set_z(pending_scale, sd[tmp_ks-1])); 
    #####:  344:        SPEX_CHECK(SPEX_mpq_set_den(pending_scale, sd[last_nz_b4_ks])); 
    #####:  345:        SPEX_CHECK(SPEX_mpq_canonicalize(pending_scale));
    #####:  346:        SPEX_CHECK(SPEX_mpq_mul(SPEX_2D(S, 3, tmp_ks),
        -:  347:                                SPEX_2D(S, 3, tmp_ks), pending_scale));
        -:  348:    }
        -:  349:
        -:  350:    // d(ks)       = U(ks,Q(ks));
    #####:  351:    SPEX_CHECK(SPEX_mpz_set(     d[tmp_ks]       , Uk_dense_row->x[Q[tmp_ks]]));
        -:  352:    // sd(ks)      = U(ks,Q(ks))*S(3,ks)
    #####:  353:    SPEX_CHECK(SPEX_mpz_divexact(sd[tmp_ks], d[tmp_ks], SPEX_MPQ_DEN(SPEX_2D(S,3,tmp_ks))));
    #####:  354:    SPEX_CHECK(SPEX_mpz_mul     (sd[tmp_ks],sd[tmp_ks], SPEX_MPQ_NUM(SPEX_2D(S,3,tmp_ks))));
        -:  355:
        -:  356:    // no need to update L(P(ks), ks), which will be updated in the
        -:  357:    // last iteration
        -:  358:    //SPEX_CHECK(SPEX_mpz_set(Lk_dense_col[P[tmp_ks]],Uk_dense_row[Q[tmp_ks]]));
    #####:  359:    if (ks == n)
        -:  360:    {
        -:  361:        // move data from Uk_dense_row, there is only one entry that needs
        -:  362:        // to move, which is U(k,Q[n-1])
        -:  363:        // set U(n-1,n-1)=L(n-1,n-1)=Uk_dense_row[Q[n-1]]
    #####:  364:        SPEX_CHECK(SPEX_mpz_swap(U->v[n-1]->x[0], Uk_dense_row->x[Q[n-1]]));
    #####:  365:        SPEX_CHECK(SPEX_mpz_set (L->v[n-1]->x[0], U->v[n-1]->x[0]     ));
    #####:  366:        U->v[n-1]->i[0] = Q[n-1];
    #####:  367:        U->v[n-1]->nz = 1;
        -:  368:    }
        -:  369:
    #####:  370:    SPEX_FREE_ALL;
    #####:  371:    return SPEX_OK;
        -:  372:}
