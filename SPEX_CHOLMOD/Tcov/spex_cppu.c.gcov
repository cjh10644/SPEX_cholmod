        -:    0:Source:spex_cppu.c
        -:    0:Graph:spex_cppu.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_CHOLMOD/spex_cppu.c: perform column permutation pivot update
        -:    3://------------------------------------------------------------------------------
        -:    4:
        -:    5:// SPEX_CHOLMOD: (c) 2020-2021, Jinhao Chen, Timothy A. Davis, Erick
        -:    6:// Moreno-Centeno, Texas A&M University.  All Rights Reserved.  See
        -:    7:// SPEX_CHOLMOD/License for the license.
        -:    8:
        -:    9://------------------------------------------------------------------------------
        -:   10:
        -:   11:// Purpose: This function is called to perform column permutation pivot update
        -:   12:// when the submatrix (formed by rows and columns k to ks) has the following
        -:   13:// pattern
        -:   14://       x 0 0 0 x
        -:   15://       . x . . .
        -:   16://       . . x . .
        -:   17://       . . . x .
        -:   18://       . . . . x
        -:   19:// This function will swap columns k and ks in L and U. Noted that the columns
        -:   20:// of U are permuted implicitly via the permutation matrix based on Q.
        -:   21:
        -:   22:#define SPEX_FREE_ALL                \
        -:   23:    SPEX_MPZ_CLEAR(Uiks);            \
        -:   24:    SPEX_MPQ_CLEAR(one);             \
        -:   25:    SPEX_MPQ_CLEAR(tmpq);            \
        -:   26:    SPEX_MPQ_CLEAR(pending_scale);   \
        -:   27:    SPEX_MPZ_CLEAR(tmpz);
        -:   28:
        -:   29:#include "spex_internal.h"
        -:   30:
    #####:   31:SPEX_info spex_cppu
        -:   32:(
        -:   33:    SPEX_matrix *L,  // matrix L
        -:   34:    SPEX_matrix *U,  // matrix U
        -:   35:    mpq_t *S,        // array of size 3*n that stores pending scales
        -:   36:    mpz_t *d,        // array of size n that stores the unscaled pivot
        -:   37:    mpz_t *sd,       // array of size n that stores the scaled pivot
        -:   38:    spex_scattered_vector *Lk_dense_col,// scattered column k of L
        -:   39:    spex_scattered_vector *Uk_dense_row,// scattered column k of U
        -:   40:    const mpq_t vk_scale,// scale factor for newly inserted column vk, which
        -:   41:                     // should be in col k of L in the last iteration when used.
        -:   42:    int64_t *inext,  // the index of first off-diag entry in col k of L
        -:   43:    int64_t *jnext,  // the index of first off-diag entry in row k of U
        -:   44:    int64_t *h,      // allocated vector that can be used for history vector.
        -:   45:                     // All entries are maintained to be >= -1
        -:   46:    int64_t *Q,      // column permutation
        -:   47:    int64_t *Q_inv,  // inverse of column permutation
        -:   48:    const int64_t *P,// row permutation
        -:   49:    const int64_t *P_inv,// inverse of row permutation
        -:   50:    int64_t *Ldiag,  // L(k,k) can be found as L->v[k]->x[Ldiag[k]]
        -:   51:    const int64_t *Uci,// the row index for col-wise nnz pattern of U
        -:   52:    const int64_t *Ucp,// col pointers for col-wise nnz pattern of U
        -:   53:    const int64_t *Ucx,// the value of k-th entry is found as
        -:   54:                     // U->v[Uci[k]]->x[Ucx[k]]
        -:   55:    const int64_t k, // current column index 0 <= k < n
        -:   56:    const int64_t ks // index of the diagonal to be swapped with, [0,n)
        -:   57:)
        -:   58:{
        -:   59:    // initialize workspace
        -:   60:    SPEX_info info;
        -:   61:    int sgn, r;
    #####:   62:    int64_t pk, ck, pks, cks, pi, ci, i, j, n = U->n;
        -:   63:    // the pointer for U(k,Q(ks)) = U->v[k]->x[Ucx[Ucp_k_ks]]
        -:   64:    int64_t Ucp_k_ks;
    #####:   65:    *inext = n;
    #####:   66:    *jnext = n;
        -:   67:
        -:   68:    mpq_t pending_scale, tmpq, one;
    #####:   69:    SPEX_MPQ_SET_NULL(pending_scale); SPEX_MPQ_SET_NULL(tmpq);
    #####:   70:    mpz_t Uiks, tmpz; SPEX_MPZ_SET_NULL(Uiks); SPEX_MPZ_SET_NULL(tmpz);
    #####:   71:    SPEX_CHECK(SPEX_mpq_init(pending_scale));
    #####:   72:    SPEX_CHECK(SPEX_mpq_init(tmpq));
    #####:   73:    SPEX_CHECK(SPEX_mpq_init(one));
    #####:   74:    SPEX_CHECK(SPEX_mpq_set_ui(one, 1, 1));
    #####:   75:    SPEX_CHECK(SPEX_mpz_init(Uiks));
    #####:   76:    SPEX_CHECK(SPEX_mpz_init(tmpz));
        -:   77:
    #####:   78:    if (ks == n)
        -:   79:    {
        -:   80:        // since the value in Uk_dense_row[Q[k]] will not be used, we use it to
        -:   81:        // hold the original value of sd[k] before swapping column k with
        -:   82:        // column n-1. Then we set sd[k] to d[k]=vk[P[k]] with pending scaling
        -:   83:        // factor applied
    #####:   84:        SPEX_CHECK(SPEX_mpz_swap(Uk_dense_row->x[Q[k]], sd[k]));
    #####:   85:        SPEX_CHECK(SPEX_mpz_divexact(sd[k],  d[k], SPEX_MPQ_DEN(vk_scale)));
    #####:   86:        SPEX_CHECK(SPEX_mpz_mul     (sd[k], sd[k], SPEX_MPQ_NUM(vk_scale)));
        -:   87:
        -:   88:        // get the scale for entries between frames k and n-1
        -:   89:        // pending_scale = sd(k)/Uk_dense_row[Q[k]]
    #####:   90:        SPEX_CHECK(SPEX_mpq_set_z(pending_scale, sd[k]));
    #####:   91:        SPEX_CHECK(SPEX_mpq_set_den(pending_scale, Uk_dense_row->x[Q[k]]));
    #####:   92:        SPEX_CHECK(SPEX_mpq_canonicalize(pending_scale));
        -:   93:
        -:   94:        // if the inserted column is used, we won't need to perform
        -:   95:        // backtracking. Instead, we just need to perform RwSOP. If U(k,
        -:   96:        // Q[n-1]) == 0, RwSOP is simplified as pure scaling for all frame from
        -:   97:        // k+1:n-1. Otherwise, we need to first compute the (n-1)-th IPGE
        -:   98:        // iteration for the column k, and use the result to perform RwSOP on
        -:   99:        // column n-1 of U.
    #####:  100:        SPEX_CHECK(SPEX_mpz_sgn(&sgn, Uk_dense_row->x[Q[n-1]]));
    #####:  101:        if (sgn == 0)
        -:  102:        {
        -:  103:            // just need to perform RwSOP by scaling all frame k+1:n-1
    #####:  104:            for (j = k+1; j < n; j++)
        -:  105:            {
        -:  106:                // S(3,k+1:n-1) = S(3,k+1:n-1)*pending_scale;
    #####:  107:                SPEX_CHECK(SPEX_mpq_mul(SPEX_2D(S, 3, j),
        -:  108:                                        SPEX_2D(S, 3, j), pending_scale));
        -:  109:                // sd(k+1:n-1) = sd(k+1:n-1)*pending_scale;
    #####:  110:                SPEX_CHECK(SPEX_mpz_divexact(sd[j],
        -:  111:                                        sd[j], SPEX_MPQ_DEN(pending_scale)));
    #####:  112:                SPEX_CHECK(SPEX_mpz_mul(sd[j],
        -:  113:                                        sd[j], SPEX_MPQ_NUM(pending_scale)));
        -:  114:            }
        -:  115:
        -:  116:            // move data from Uk_dense_row, but there is no entry that needs
        -:  117:            // to move
    #####:  118:            U->v[k]->nz = 0;
        -:  119:        }
        -:  120:        else
        -:  121:        {
        -:  122:            // S(2,k) = S(2,k)*S(3,k)
    #####:  123:            SPEX_CHECK(SPEX_mpq_mul(SPEX_2D(S, 2, k),
        -:  124:                                    SPEX_2D(S, 2, k), SPEX_2D(S, 3, k)));
        -:  125:            // U(k,Q[n-1]) = U(k, Q[n-1])*S(2,k)
    #####:  126:            SPEX_CHECK(SPEX_mpz_divexact(Uk_dense_row->x[Q[n-1]],
        -:  127:                      Uk_dense_row->x[Q[n-1]], SPEX_MPQ_DEN(SPEX_2D(S, 2, k))));
    #####:  128:            SPEX_CHECK(SPEX_mpz_mul(Uk_dense_row->x[Q[n-1]],
        -:  129:                      Uk_dense_row->x[Q[n-1]], SPEX_MPQ_NUM(SPEX_2D(S, 2, k))));
        -:  130:
        -:  131:            // perform 1 IPGE iteration on Lk_dense_col using vk and update the
        -:  132:            // history vector. Then use L to perform the remaining IPGE update
        -:  133:            // till (n-1)-th iteration. Finally, use the result to update
        -:  134:            // column n-1 of U.
        -:  135:            // It should be noted that, since the resulted column in the
        -:  136:            // (n-1)-th IPGE iteration is computed using column k of L instead
        -:  137:            // of the inserted column, its sign should be flipped when applying
        -:  138:            // RwSOP.
        -:  139:            // initialize history vector
    #####:  140:            for (pk = 0; pk < Lk_dense_col->nz; pk++)
        -:  141:            {
    #####:  142:                ck = Lk_dense_col->i[pk];
    #####:  143:                h[ck] = SPEX_FLIP(k-1);
        -:  144:            }
    #####:  145:            for (pk = 0; pk < L->v[k]->nz; pk++)
        -:  146:            {
    #####:  147:                ck = L->v[k]->i[pk];
    #####:  148:                SPEX_CHECK(SPEX_mpz_sgn(&sgn, L->v[k]->x[pk]));
    #####:  149:                if (sgn == 0)       { continue;   }
        -:  150:
        -:  151:                // L(ck,k) = (L(ck, k)*vk(P[k])-L(P[k],k)*vk(ck))/sd[k-1]
    #####:  152:                SPEX_CHECK(SPEX_mpz_sgn(&sgn, Lk_dense_col->x[ck]));
    #####:  153:                if (sgn != 0)
        -:  154:                {
    #####:  155:                    SPEX_CHECK(SPEX_mpz_mul(Lk_dense_col->x[ck],
        -:  156:                                            Lk_dense_col->x[ck], d[k]));
        -:  157:                }
    #####:  158:                else if (h[ck] >= -1) //this entry wasn't in the nnz pattern
        -:  159:                {
        -:  160:                    // insert new entry in the nonzero pattern
    #####:  161:                    Lk_dense_col->i[Lk_dense_col->nz] = ck;
    #####:  162:                    Lk_dense_col->nz++;
        -:  163:                }
    #####:  164:                SPEX_CHECK(SPEX_mpz_addmul(Lk_dense_col->x[ck],
        -:  165:                                        Lk_dense_col->x[P[k]], L->v[k]->x[pk]));
    #####:  166:                if (k > 0)
        -:  167:                {
    #####:  168:                    SPEX_CHECK(SPEX_mpz_divexact(Lk_dense_col->x[ck],
        -:  169:                                             Lk_dense_col->x[ck], sd[k-1]));
        -:  170:                }
    #####:  171:                h[ck] = SPEX_FLIP(k);
        -:  172:            }
        -:  173:            // S(1,k) = vk_scale, the existing pending scale for column k of L
        -:  174:            // can be ignored when performing RwSOP
    #####:  175:            SPEX_CHECK(SPEX_mpq_set(SPEX_2D(S, 1, k), vk_scale));
        -:  176:
        -:  177:            // perform IPGE and RwSOP
    #####:  178:            for (i = k+1; i < n; i++)
        -:  179:            {
        -:  180:                // if Lk_dense_col[P[i]] == 0, just perform RwSOP
    #####:  181:                SPEX_CHECK(SPEX_mpz_sgn(&sgn, Lk_dense_col->x[P[i]]));
    #####:  182:                if (sgn == 0) 
        -:  183:                {
    #####:  184:                    SPEX_CHECK(SPEX_mpq_mul(SPEX_2D(S, 3, i),
        -:  185:                                            SPEX_2D(S, 3, i), pending_scale));
    #####:  186:                    SPEX_CHECK(SPEX_mpz_divexact(sd[i], sd[i],
        -:  187:                                            SPEX_MPQ_DEN(pending_scale)));
    #####:  188:                    SPEX_CHECK(SPEX_mpz_mul(sd[i], sd[i],
        -:  189:                                            SPEX_MPQ_NUM(pending_scale)));
    #####:  190:                    continue;
        -:  191:                }
        -:  192:
        -:  193:                // perform RwSOP for row i with flipped-sign entries in
        -:  194:                // Lk_dense_col. All entries in row i of U must be SCALEUP such
        -:  195:                // that S(:,i)=[S(1,i)*S(3,i);1;1]
    #####:  196:                SPEX_CHECK(SPEX_mpq_equal(&r, SPEX_2D(S, 3, i), one));
    #####:  197:                if (r == 0) // S(3,i) != 1
        -:  198:                {
        -:  199:                    // S(:,i) = [S(1,i)*S(3,i); S(2,i)*S(3,i); 1]
    #####:  200:                    SPEX_CHECK(SPEX_mpq_mul(SPEX_2D(S, 1, i),
        -:  201:                                            SPEX_2D(S, 1, i), SPEX_2D(S, 3,i)));
    #####:  202:                    SPEX_CHECK(SPEX_mpq_mul(SPEX_2D(S, 2, i),
        -:  203:                                            SPEX_2D(S, 2, i), SPEX_2D(S, 3,i)));
    #####:  204:                    SPEX_CHECK(SPEX_mpq_set_ui(SPEX_2D(S, 3, i), 1, 1));
        -:  205:                }
        -:  206:                // S(2,i) = S(2, i)*pending_scale;
    #####:  207:                SPEX_CHECK(SPEX_mpq_mul(SPEX_2D(S, 2, i),
        -:  208:                                        SPEX_2D(S, 2, i), pending_scale));
        -:  209:
    #####:  210:                if (i != n-1)
        -:  211:                {
        -:  212:                    // perform i-th IPGE update for Lk_dense_col
    #####:  213:                    SPEX_CHECK(spex_ipge(Lk_dense_col, SPEX_2D(S, 1, k), h,
        -:  214:                        NULL, L->v[i], P, P_inv, (const mpz_t*) sd,
        -:  215:                        SPEX_2D(S, 1, i), one, Ldiag[i], i));
        -:  216:                }
        -:  217:                else
        -:  218:                {
        -:  219:                    // finish history update for last entry of Lk_dense_col
    #####:  220:                    ck = P[n-1];
    #####:  221:                    int64_t real_h = SPEX_FLIP(h[ck]);
    #####:  222:                    if (real_h < n-1) // require history update
        -:  223:                    {
    #####:  224:                        SPEX_CHECK(SPEX_mpz_mul(Lk_dense_col->x[ck],
        -:  225:                                             Lk_dense_col->x[ck], sd[n-1]));
    #####:  226:                        if (real_h > -1)
        -:  227:                        {
    #####:  228:                            SPEX_CHECK(SPEX_mpz_divexact(Lk_dense_col->x[ck],
        -:  229:                                             Lk_dense_col->x[ck], sd[real_h]));
        -:  230:                        }
        -:  231:                    }
    #####:  232:                    SPEX_CHECK(SPEX_mpz_divexact(Lk_dense_col->x[ck],
        -:  233:                        Lk_dense_col->x[ck], SPEX_MPQ_DEN(SPEX_2D(S, 1, k))));
    #####:  234:                    SPEX_CHECK(SPEX_mpz_mul(Lk_dense_col->x[ck],
        -:  235:                        Lk_dense_col->x[ck], SPEX_MPQ_NUM(SPEX_2D(S, 1, k))));
        -:  236:                }
        -:  237:
    #####:  238:                int64_t p = -1; // the pointer to U(i,Q(n-1))
        -:  239:                // iterate all nnz in row i of U
    #####:  240:                for (pi = 0; pi < U->v[i]->nz; pi++)
        -:  241:                {
    #####:  242:                    ci = U->v[i]->i[pi];
    #####:  243:                    if (Q_inv[ci] < n-1)
        -:  244:                    {
        -:  245:                        // apply S(2,i) to U(i,Q(i:n-2))
    #####:  246:                        SPEX_CHECK(SPEX_mpz_divexact(U->v[i]->x[pi],
        -:  247:                               U->v[i]->x[pi], SPEX_MPQ_DEN(SPEX_2D(S, 2, i))));
    #####:  248:                        SPEX_CHECK(SPEX_mpz_mul(U->v[i]->x[pi],
        -:  249:                               U->v[i]->x[pi], SPEX_MPQ_NUM(SPEX_2D(S, 2, i))));
        -:  250:                        // set sd[i] = U(i, Q(i))
    #####:  251:                        if (ci == Q[i])
        -:  252:                        {
    #####:  253:                            SPEX_CHECK(SPEX_mpz_set(sd[i], U->v[i]->x[pi]));
        -:  254:                        }
        -:  255:                    }
        -:  256:                    else
        -:  257:                    {
    #####:  258:                        p = pi;
        -:  259:                    }
        -:  260:                }
        -:  261:                // perform RwSOP to U(i,Q(n-1)), POSSIBLE FILLIN
        -:  262:                // sign is changed here due to column swap
        -:  263:                // U(i,ci)= U(i,ci)*S(2,i) +
        -:  264:                //        Lk_dense_col(P[i])*U(k,ci)/Lk_dense_col[P[k]]
    #####:  265:                ci = Q[n-1];
    #####:  266:                if (p > -1)
        -:  267:                {
    #####:  268:                    SPEX_CHECK(SPEX_mpz_mul(U->v[i]->x[p],
        -:  269:                               U->v[i]->x[p], SPEX_MPQ_NUM(SPEX_2D(S, 2, i))));
    #####:  270:                    SPEX_CHECK(SPEX_mpz_fdiv_q(U->v[i]->x[p],
        -:  271:                               U->v[i]->x[p], SPEX_MPQ_DEN(SPEX_2D(S, 2, i))));
    #####:  272:                    SPEX_CHECK(SPEX_mpz_mul(tmpz,
        -:  273:                               Lk_dense_col->x[P[i]], Uk_dense_row->x[ci]));
    #####:  274:                    SPEX_CHECK(SPEX_mpz_cdiv_q(tmpz, tmpz,
        -:  275:                               Lk_dense_col->x[P[k]]));
    #####:  276:                    SPEX_CHECK(SPEX_mpz_add(U->v[i]->x[p],U->v[i]->x[p], tmpz));
        -:  277:                }
        -:  278:                else // U(i,Q(n-1)) was not in the nnz pattern
        -:  279:                {
    #####:  280:                    p = U->v[i]->nz;
        -:  281:                    // reallocate the nonzero pattern if needed
    #####:  282:                    if (p == U->v[i]->nzmax)
        -:  283:                    {
    #####:  284:                        SPEX_CHECK(SPEX_vector_realloc(U->v[i],
        -:  285:                            2*(U->v[i]->nzmax)));
        -:  286:                    }
        -:  287:                    // insert new entry in the nonzero pattern
    #####:  288:                    U->v[i]->i[p] = ci;
    #####:  289:                    U->v[i]->nz++;
        -:  290:
    #####:  291:                    SPEX_CHECK(SPEX_mpz_mul(U->v[i]->x[p],
        -:  292:                                  Lk_dense_col->x[P[i]], Uk_dense_row->x[ci]));
    #####:  293:                    SPEX_CHECK(SPEX_mpz_divexact(U->v[i]->x[p],
        -:  294:                                  U->v[i]->x[p], Lk_dense_col->x[P[k]]));
        -:  295:                }
    #####:  296:                SPEX_CHECK(SPEX_mpq_set_ui(SPEX_2D(S, 2, i), 1, 1));
        -:  297:            }
        -:  298:            // L(P(n-1),n-1) = d(n-1) = sd(n-1) = U(n-1, Q(n-1))
    #####:  299:            SPEX_CHECK(SPEX_mpz_set(L->v[n-1]->x[0], U->v[n-1]->x[0]));
    #####:  300:            SPEX_CHECK(SPEX_mpz_set(   d[n-1]      , U->v[n-1]->x[0]));
    #####:  301:            SPEX_CHECK(SPEX_mpz_set(  sd[n-1]      , U->v[n-1]->x[0]));
        -:  302:            // S(:,n-1) = ones
    #####:  303:            SPEX_CHECK(SPEX_mpq_set(SPEX_2D(S, 1, n-1), one));
    #####:  304:            SPEX_CHECK(SPEX_mpq_set(SPEX_2D(S, 2, n-1), one));
    #####:  305:            SPEX_CHECK(SPEX_mpq_set(SPEX_2D(S, 3, n-1), one));
        -:  306:
        -:  307:            // move data from Uk_dense_row, there is only one entry that needs
        -:  308:            // to move, which is U(k,Q[n-1]) and has no pending scale
    #####:  309:            SPEX_CHECK(SPEX_mpz_swap(U->v[k]->x[0], Uk_dense_row->x[Q[n-1]]));
    #####:  310:            U->v[k]->i[0] = Q[n-1];
    #####:  311:            U->v[k]->nz = 1;
        -:  312:        }
        -:  313:
    #####:  314:        SPEX_FREE_ALL;
    #####:  315:        return SPEX_OK;
        -:  316:    }
        -:  317:    //-------------------------------------------------------------------------
        -:  318:    // Backtracking column ks of L and U, the backtracking result will be moved
        -:  319:    // to column k of L and entries in column ks of L are moved to
        -:  320:    // Lk_dense_col.
        -:  321:    //-------------------------------------------------------------------------
        -:  322:    // When U(k+1:ks-1,Q(ks)) are all zero(s), there is no need to make a copy
        -:  323:    // of Lk_dense_col. Instead, we can direct operate on Lk_dense_col.
        -:  324:    // Otherwise, Lk_dense_col will firstly be moved to L->v[k]->x in a
        -:  325:    // compressed-column form. Then Lk_dense_col will make a copy of ks-th
        -:  326:    // column of scaled L and scaled U(k:ks-1,Q(ks)). Backtracking will be
        -:  327:    // performed on Lk_dense_col for each nonzero in U(k:ks-1, Q(ks)).
        -:  328:    //-------------------------------------------------------------------------
        -:  329:    // initialized to be 2nd last entry in the Q[ks]-th col of U
    #####:  330:    Ucp_k_ks = Ucp[Q[ks]+1]-2;
    #####:  331:    if (Uci[Ucp_k_ks] == k) // 2nd last nnz in U(:,Q(ks)) is at row k
        -:  332:    {
        -:  333:        // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
        -:  334:        // backtracking jumbled sparse column ks of L using 'dense' column k of
        -:  335:        // L and store the result in Lk_dense_col. This will introduce new
        -:  336:        // entry to Lk_dense_col.
        -:  337:        // Assuming explicit zeros in L(:, ks) resulted from exact
        -:  338:        // cancellation in IPGE update were not removed (SLIP LU keeps those
        -:  339:        // zeros in output L and U), nonzero pattern of L(P(k+1:n+1),k) should
        -:  340:        // be a subset of U(:,ks). Therefore, the backtracking will need to 
        -:  341:        // simply iterate all nonzero in the L(:,ks), and the final Lk_dense_col
        -:  342:        // will have mostly the same nnz pattern as L(:,ks), except L(P(k),k).
        -:  343:        //
        -:  344:        // REMARK:
        -:  345:        // when the IPGE update results in exact cancellation and the resulted
        -:  346:        // zero is removed from L or U, new entry will be inserted to
        -:  347:        // Lk_dense_col during backtracking. In this case, we need to
        -:  348:        // additionally iterate across all nonzeros in Lk_dense_col to find if
        -:  349:        // any row index of nonzero is untouched, then perform the following
        -:  350:        // L(i,k) = L(i,k)*U(k, Q[ks])/L(P(k),k)
        -:  351:        // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        -:  352:        // Uiks = U(k,Q(ks))*S(2,k)*S(3,k)
    #####:  353:        SPEX_CHECK(SPEX_mpq_mul(SPEX_2D(S, 2, k), SPEX_2D(S, 2, k),
        -:  354:                                SPEX_2D(S, 3, k)));
    #####:  355:        SPEX_CHECK(SPEX_mpz_divexact(Uiks, Uk_dense_row->x[Q[ks]],
        -:  356:                                SPEX_MPQ_DEN(SPEX_2D(S, 2, k))));
    #####:  357:        SPEX_CHECK(SPEX_mpz_mul(Uiks, Uiks,
        -:  358:                                SPEX_MPQ_NUM(SPEX_2D(S, 2, k))));
        -:  359:        // update d[k] = U(k, Q(ks))
    #####:  360:        SPEX_CHECK(SPEX_mpz_set(d[k], Uk_dense_row->x[Q[ks]]));
        -:  361:
    #####:  362:        if (k > 0)
        -:  363:        {
    #####:  364:            SPEX_CHECK(SPEX_mpq_set_z(pending_scale, sd[k-1]));
        -:  365:        }
        -:  366:        else
        -:  367:        {
    #####:  368:            SPEX_CHECK(SPEX_mpq_set_ui(pending_scale, 1, 1));
        -:  369:        }
    #####:  370:        SPEX_CHECK(SPEX_mpq_set_den(pending_scale, sd[ks-1]));
        -:  371:        // remove common factor in mpq_den and mpq_num
    #####:  372:        SPEX_CHECK(SPEX_mpq_canonicalize(pending_scale));
    #####:  373:        SPEX_CHECK(SPEX_mpq_mul(pending_scale, pending_scale, SPEX_2D(S,1,ks)));
    #####:  374:        SPEX_CHECK(SPEX_mpq_mul(pending_scale, pending_scale, SPEX_2D(S,3,ks)));
        -:  375:        // perform backtracking for each nonzero in col ks of L and store
        -:  376:        // results in Lk_dense_col
        -:  377:        // NOTE: this will cause fillin in the k(th) column of L
        -:  378:        // make sure L->v[k] has enough space
    #####:  379:        if (L->v[k]->nzmax < L->v[ks]->nzmax+1)
        -:  380:        {
    #####:  381:            SPEX_CHECK(SPEX_vector_realloc(L->v[k], L->v[ks]->nzmax+1));
        -:  382:        }
    #####:  383:        pk = 0;
    #####:  384:        for (pks = 0; pks < L->v[ks]->nz; pks++)
        -:  385:        {
        -:  386:            // row index in column ks of L
    #####:  387:            cks = L->v[ks]->i[pks];
        -:  388:
        -:  389:            // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        -:  390:            // L(cks,k) = L(cks,k)*Uiks/L(P[k],k)+L(cks,ks)*pending_scale
        -:  391:            // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    #####:  392:            SPEX_CHECK(SPEX_mpz_sgn(&sgn, Lk_dense_col->x[cks]));
    #####:  393:            if (sgn != 0)
        -:  394:            {
        -:  395:                // L(cks,k) = floor(L(cks,k)*Uiks/L(P[k],k))
    #####:  396:                SPEX_CHECK(SPEX_mpz_mul(Lk_dense_col->x[cks],
        -:  397:                           Lk_dense_col->x[cks], Uiks));
    #####:  398:                SPEX_CHECK(SPEX_gmp_printf("%Zd/%Zd=", Lk_dense_col->x[cks],
        -:  399:                           L->v[k]->x[Ldiag[k]]));
    #####:  400:                SPEX_CHECK(SPEX_mpz_fdiv_q(Lk_dense_col->x[cks],
        -:  401:                           Lk_dense_col->x[cks], L->v[k]->x[Ldiag[k]]));
    #####:  402:                SPEX_CHECK(SPEX_gmp_printf("%Zd\n", Lk_dense_col->x[cks]));
        -:  403:
        -:  404:                // tmpz = ceil(L(cks,ks)*pending_scale)
    #####:  405:                SPEX_CHECK(SPEX_mpz_mul(tmpz, L->v[ks]->x[pks],
        -:  406:                           SPEX_MPQ_NUM(pending_scale)));
    #####:  407:                SPEX_CHECK(SPEX_mpz_cdiv_q(tmpz, tmpz,
        -:  408:                           SPEX_MPQ_DEN(pending_scale)));
        -:  409:                // L(cks,k) = L(cks,k)+tmpz
    #####:  410:                SPEX_CHECK(SPEX_mpz_add(Lk_dense_col->x[cks],
        -:  411:                           Lk_dense_col->x[cks], tmpz));
        -:  412:            }
        -:  413:            else  // faster 
        -:  414:            {
        -:  415:                // L(cks,k) = L(cks,ks)*pending_scale
    #####:  416:                SPEX_CHECK(SPEX_mpz_divexact(Lk_dense_col->x[cks],
        -:  417:                           L->v[ks]->x[pks], SPEX_MPQ_DEN(pending_scale)));
    #####:  418:                SPEX_CHECK(SPEX_mpz_mul(Lk_dense_col->x[cks],
        -:  419:                           Lk_dense_col->x[cks], SPEX_MPQ_NUM(pending_scale)));
        -:  420:            }
        -:  421:
        -:  422:            // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        -:  423:            // move nonzero entry from Lk_dense_col to L->v[k]->x
        -:  424:            // NOTE: explicit zero due to exact cancellation in backtracking
        -:  425:            //       is removed
        -:  426:            // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    #####:  427:            SPEX_CHECK(SPEX_mpz_sgn(&sgn, Lk_dense_col->x[cks]));
    #####:  428:            if (sgn != 0)
        -:  429:            {
    #####:  430:                L->v[k]->i[pk] = cks;
    #####:  431:                SPEX_CHECK(SPEX_mpz_swap(L->v[k]->x[pk], Lk_dense_col->x[cks]));
    #####:  432:                pk++;
        -:  433:            }
        -:  434:            // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        -:  435:            // swap values from L->v[ks]->x and Lk_dense_col
        -:  436:            // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    #####:  437:            SPEX_CHECK(SPEX_mpz_sgn(&sgn, L->v[ks]->x[pks]));
    #####:  438:            if (sgn != 0 && P_inv[cks] < *inext && P_inv[cks] > ks)
        -:  439:            {
    #####:  440:                *inext = P_inv[cks];
        -:  441:            }
    #####:  442:            SPEX_CHECK(SPEX_mpz_swap(Lk_dense_col->x[cks], L->v[ks]->x[pks]));
        -:  443:        }
        -:  444:        // update L(P(k),k) and reset Lk_dense_col[P[k]]
    #####:  445:        L->v[k]->i[pk] = P[k];
    #####:  446:        SPEX_CHECK(SPEX_mpz_set(sd[k], Uiks));
    #####:  447:        SPEX_CHECK(SPEX_mpz_swap(L->v[k]->x[pk], Uiks));
    #####:  448:        SPEX_CHECK(SPEX_mpz_set_ui(Lk_dense_col->x[P[k]], 0));
    #####:  449:        Ldiag[k] = pk;
    #####:  450:        pk++;
        -:  451:        // update number of nnz
    #####:  452:        L->v[k]->nz = pk;
        -:  453:
        -:  454:        // get the pointer for U(k,Q(ks)) = U->v[k]->x[Ucx[Ucp_k_ks]]
        -:  455:        // Ucp_k_ks = Ucp[Q[ks]+1]-2; // 2nd last entry in the Q[ks]-th col of U
        -:  456:    }
        -:  457:    else  // U(ks+1:k-1,Q(ks)) contains nnz(s)
        -:  458:    {
        -:  459:        // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        -:  460:        // construct column k of L based on Lk_dense_col
        -:  461:        // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    #####:  462:        if (Lk_dense_col->nz > L->v[k]->nzmax)
        -:  463:        {
    #####:  464:            SPEX_CHECK(SPEX_vector_realloc(L->v[k], Lk_dense_col->nz));
        -:  465:        }
    #####:  466:        for (pk = 0; pk < Lk_dense_col->nz; pk++)
        -:  467:        {
    #####:  468:            ck = Lk_dense_col->i[pk];
    #####:  469:            L->v[k]->i[pk] = ck;
    #####:  470:            if (ck == P[k])
        -:  471:            {
    #####:  472:                Ldiag[k] = pk;  // update Ldiag[k]
        -:  473:            }
        -:  474:            // swap the entries in the Lk_dense_col and L->v[k]->x
    #####:  475:            SPEX_CHECK(SPEX_mpz_swap(L->v[k]->x[pk], Lk_dense_col->x[ck]));
        -:  476:        }
    #####:  477:        L->v[k]->nz = Lk_dense_col->nz;
    #####:  478:        Lk_dense_col->nz = 0;
        -:  479:
        -:  480:        // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        -:  481:        // initialize history vector h and copy L->v[ks]->x to Lk_dense_col.
        -:  482:        // Explicit zero(s) are kept if exist
        -:  483:        // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    #####:  484:        for (pks = 0; pks < L->v[ks]->nz; pks++) 
        -:  485:        { 
    #####:  486:            cks = L->v[ks]->i[pks]; 
        -:  487:            // copy value from L->v[ks]->x to Lk_dense_col, no need to copy i
    #####:  488:            SPEX_CHECK(SPEX_mpz_set(Lk_dense_col->x[cks], L->v[ks]->x[pks]));
        -:  489:            // Assuming that zero resulted from exact cancellation is kept in
        -:  490:            // the nnz pattern, then performing backtracking will not introduce
        -:  491:            // new fillin. That is, for any i such that U(i,Q[ks])!=0, the nnz
        -:  492:            // pattern of L(i+1:n, i) is a subset of the nnz pattern of
        -:  493:            // Lk_dense_col(i+1:n). Therefore, the final nnz pattern can be
        -:  494:            // found by L->v[ks]->i and column-wise nnz pattern of U(:,ks)
        -:  495:            //
        -:  496:            // However, when explicit zero(s) are always eleminated, the
        -:  497:            // following initialization should be used instead:
        -:  498:            //
        -:  499:            // h[cks] = SPEX_FLIP(ks-1); 
        -:  500:            //
        -:  501:            // With such initialization, entry with h > -1 is clearly not in
        -:  502:            // nnz pattern and any entry in the nnz pattern with h = -1 must be
        -:  503:            // nonzero. In all, any explicit zero with h >= -1 must not be in
        -:  504:            // the nnz pattern.  In this way, we can determine if a zero entry
        -:  505:            // in Lk_dense_col is in the nnz pattern.
    #####:  506:            h[cks] = ks-1;
        -:  507:        }
        -:  508:
        -:  509:        // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        -:  510:        // backtrack column ks of L and U for each nnz in U(k:ks-1,Q(ks))
        -:  511:        // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    #####:  512:        pks = Ucp[Q[ks]+1]-2; // 2nd last entry in the Q[ks]-th col of U
    #####:  513:        i = Uci[pks];         // row index
    #####:  514:        while (i >= k)
        -:  515:        {
        -:  516:            // skip if U(i, Q[ks]) turns out to be explicit zero
        -:  517:            // no need to initialize history vector for this entry
    #####:  518:            SPEX_CHECK(SPEX_mpz_sgn(&sgn, U->v[i]->x[Ucx[pks]]));
    #####:  519:            if (sgn == 0)   { continue; }
        -:  520:
        -:  521:            // Uiks = U(i,Q(ks))*S(2,k)*S(3,k)
    #####:  522:            if (i == k)
        -:  523:            {
        -:  524:                // update S(2,k)
    #####:  525:                SPEX_CHECK(SPEX_mpq_mul(SPEX_2D(S, 2, k), SPEX_2D(S, 2, k),
        -:  526:                                        SPEX_2D(S, 3, k)));
        -:  527:                // update d[k]
    #####:  528:                SPEX_CHECK(SPEX_mpz_set(d[k], Uk_dense_row->x[Q[ks]]));
    #####:  529:                SPEX_CHECK(SPEX_mpz_divexact(Uiks, Uk_dense_row->x[Q[ks]],
        -:  530:                                        SPEX_MPQ_DEN(SPEX_2D(S, 2, k))));
    #####:  531:                SPEX_CHECK(SPEX_mpz_mul(Uiks, Uiks,
        -:  532:                                        SPEX_MPQ_NUM(SPEX_2D(S, 2, k))));
        -:  533:            }
        -:  534:            else
        -:  535:            {
    #####:  536:                SPEX_CHECK(SPEX_mpq_mul(pending_scale, SPEX_2D(S, 2, i),
        -:  537:                                        SPEX_2D(S, 3, i)));
    #####:  538:                SPEX_CHECK(SPEX_mpz_divexact(Uiks, U->v[i]->x[Ucx[pks]],
        -:  539:                                        SPEX_MPQ_DEN(pending_scale)));
    #####:  540:                SPEX_CHECK(SPEX_mpz_mul(Uiks, Uiks,
        -:  541:                                        SPEX_MPQ_NUM(pending_scale)));
        -:  542:            }
        -:  543:
        -:  544:            // r = (S(1,i)*S(3,i) == 1)
    #####:  545:            SPEX_CHECK(SPEX_mpq_mul(pending_scale, SPEX_2D(S, 1, i),
        -:  546:                                    SPEX_2D(S, 3, i)));
    #####:  547:            SPEX_CHECK(SPEX_mpq_equal(&r, pending_scale, one));
        -:  548:
        -:  549:            // pending_scale for Lk_dense_col, this will be used when
        -:  550:            // 1. there needs history update, OR
        -:  551:            // 2. S(1,i)*S(3,i) != 1, OR
        -:  552:            // 3. the first loop
        -:  553:            // pending_scale = S(1,ks)*S(3,ks)*sd[i-1] for first loop, OR
        -:  554:            // pending_scale = 1
    #####:  555:            if (i > 0)
        -:  556:            {
    #####:  557:                SPEX_CHECK(SPEX_mpq_set_z(pending_scale, sd[i-1]));
        -:  558:            }
        -:  559:            else
        -:  560:            {
    #####:  561:                SPEX_CHECK(SPEX_mpq_set_ui(pending_scale, 1, 1));
        -:  562:            }
        -:  563:            // for the 1st loop, additional scale S(1,ks)*S(3,ks) needs to apply
    #####:  564:            if (pks == Ucp[Q[ks]+1]-2)
        -:  565:            {
    #####:  566:                SPEX_CHECK(SPEX_mpq_mul(pending_scale, pending_scale,
        -:  567:                                        SPEX_2D(S, 1, ks)));
    #####:  568:                SPEX_CHECK(SPEX_mpq_mul(pending_scale, pending_scale,
        -:  569:                                        SPEX_2D(S, 3, ks)));
        -:  570:            }
    #####:  571:            for (pi = 0; pi < L->v[i]->nz; pi++)
        -:  572:            {
        -:  573:                // exclude L(P[i], i)
    #####:  574:                if (pi == Ldiag[i]) { continue; }
        -:  575:
        -:  576:                // row index of entry in column i of L
    #####:  577:                ci = U->v[i]->i[pi];
        -:  578:
    #####:  579:                SPEX_CHECK(SPEX_mpz_sgn(&sgn, Lk_dense_col->x[ci]));
    #####:  580:                if (sgn != 0)
        -:  581:                {
    #####:  582:                    if (i < SPEX_FLIP(h[ci]) || r == 0 || pks == Ucp[Q[ks]+1]-2)
        -:  583:                    {
        -:  584:                        // Lk_dense_col = Lk_dense_col*pending_scale/sd(h[ci])
        -:  585:                        //                + L(:,i)*Uiks/L(P(i),i)
        -:  586:                        // use L(P(i),i) instead of sd[i] to avoid scaling
        -:  587:                        // for L(:,i)
    #####:  588:                        SPEX_CHECK(SPEX_mpz_mul(tmpz, L->v[i]->x[pi], Uiks));
    #####:  589:                        SPEX_CHECK(SPEX_mpz_cdiv_q(tmpz, tmpz,
        -:  590:                                   L->v[i]->x[Ldiag[i]]));
        -:  591:
    #####:  592:                        SPEX_CHECK(SPEX_mpq_set_ui(tmpq, 1, 1));
    #####:  593:                        SPEX_CHECK(SPEX_mpq_set_den(tmpq, sd[h[ci]]));
    #####:  594:                        SPEX_CHECK(SPEX_mpq_mul(tmpq, tmpq, pending_scale));
        -:  595:
    #####:  596:                        SPEX_CHECK(SPEX_mpz_mul(Lk_dense_col->x[ci],
        -:  597:                                   Lk_dense_col->x[ci], SPEX_MPQ_NUM(tmpq)));
    #####:  598:                        SPEX_CHECK(SPEX_mpz_fdiv_q(Lk_dense_col->x[ci],
        -:  599:                                   Lk_dense_col->x[ci], SPEX_MPQ_DEN(tmpq)));
        -:  600:
    #####:  601:                        SPEX_CHECK(SPEX_mpz_add(Lk_dense_col->x[ci],
        -:  602:                                   Lk_dense_col->x[ci], tmpz));
        -:  603:
        -:  604:                        // update h[ci]
    #####:  605:                        h[ci] = i-1;
    #####:  606:                        continue;
        -:  607:                    }
    #####:  608:                    else if (i > 0)// more efficient
        -:  609:                    {
        -:  610:                        // Lk_dense_col = (Lk_dense_col*sd(i-1)
        -:  611:                        //                                 + L(:,i)*Uiks)/sd(i)
    #####:  612:                        SPEX_CHECK(SPEX_mpz_mul(Lk_dense_col->x[ci],
        -:  613:                                                Lk_dense_col->x[ci], sd[i-1]));
        -:  614:                    }
        -:  615:                }
    #####:  616:                SPEX_CHECK(SPEX_mpz_addmul(Lk_dense_col->x[ci],
        -:  617:                                           L->v[i]->x[pi], Uiks));
    #####:  618:                SPEX_CHECK(SPEX_mpz_divexact(Lk_dense_col->x[ci],
        -:  619:                                             Lk_dense_col->x[pi], sd[i]));
        -:  620:
        -:  621:                // update h[ci]
    #####:  622:                h[ci] = i-1;
        -:  623:            }
        -:  624:
        -:  625:            // move Uiks (scaled U(i,Q(ks)) to Lk_dense_col
    #####:  626:            SPEX_CHECK(SPEX_mpz_swap(Lk_dense_col->x[P[i]], Uiks));
        -:  627:            // update corresponding entry in the history vector
    #####:  628:            h[P[i]] = i-1;
        -:  629:
        -:  630:            // get next nnz
    #####:  631:            pks --;
    #####:  632:            if (pks < 0) { break;}
    #####:  633:            i = Uci[pks];         // row index
        -:  634:        }
        -:  635:
        -:  636:        // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        -:  637:        // 1. Iterate across all nnz in Lk_dense_col, perform history update if
        -:  638:        //   needed, then move all nonzero entry from Lk_dense_col to
        -:  639:        //   L->v[k]->x
        -:  640:        // NOTE: explicit zero due to exact cancellation in backtracking
        -:  641:        //       is removed.
        -:  642:        // 2. Swap values from L->v[ks]->x and Lk_dense_col
        -:  643:        // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        -:  644:        // reallocate the nonzero pattern if needed
    #####:  645:        int64_t required_nzmax = Ucp[Q[ks]+1]-Ucp[Q[ks]]-1 + L->v[ks]->nz;
    #####:  646:        if (L->v[k]->nzmax < required_nzmax)
        -:  647:        {
    #####:  648:            SPEX_CHECK(SPEX_vector_realloc(L->v[k], required_nzmax));
        -:  649:        }
    #####:  650:        pk = 0;
    #####:  651:        for (pks = 0; pks < L->v[ks]->nz; pks++) 
        -:  652:        {
    #####:  653:            cks = L->v[ks]->i[pks]; 
    #####:  654:            SPEX_CHECK(SPEX_mpz_sgn(&sgn, Lk_dense_col->x[cks]));
    #####:  655:            if (sgn != 0)
        -:  656:            {
        -:  657:                // check if need to perform history update
    #####:  658:                if (h[cks] != k-1)
        -:  659:                {
    #####:  660:                    if (k > 0)
        -:  661:                    {
    #####:  662:                        SPEX_CHECK(SPEX_mpz_mul(Lk_dense_col->x[cks],
        -:  663:                                   Lk_dense_col->x[cks], sd[k-1]));
        -:  664:                    }
    #####:  665:                    SPEX_CHECK(SPEX_mpz_divexact(Lk_dense_col->x[cks],
        -:  666:                               Lk_dense_col->x[cks], sd[h[cks]]));
        -:  667:                }
    #####:  668:                L->v[k]->i[pk] = cks;
    #####:  669:                SPEX_CHECK(SPEX_mpz_swap(L->v[k]->x[pk], Lk_dense_col->x[cks]));
    #####:  670:                pk++;
        -:  671:            }
    #####:  672:            SPEX_CHECK(SPEX_mpz_sgn(&sgn, L->v[ks]->x[pks]));
    #####:  673:            if (sgn != 0 && P_inv[cks] < *inext && P_inv[cks] > ks)
        -:  674:            {
    #####:  675:                *inext = P_inv[cks];
        -:  676:            }
    #####:  677:            SPEX_CHECK(SPEX_mpz_swap(Lk_dense_col->x[cks], L->v[ks]->x[pks]));
        -:  678:        }
    #####:  679:        for (pks = Ucp[Q[ks]+1]-2; pks >= Ucp[Q[ks]]; pks--)
        -:  680:        {
    #####:  681:            i = Uci[pks];         // row index
    #####:  682:            ci = P[i];
    #####:  683:            if (i == k)
        -:  684:            {
    #####:  685:                L->v[k]->i[pk] = ci;
    #####:  686:                SPEX_CHECK(SPEX_mpz_set(sd[k], Lk_dense_col->x[ci]));
    #####:  687:                SPEX_CHECK(SPEX_mpz_swap(L->v[k]->x[pk], Lk_dense_col->x[ci]));
    #####:  688:                Ldiag[k] = pk;
    #####:  689:                pk++;
    #####:  690:                Ucp_k_ks = pks;
    #####:  691:                break;  // this is the last nonzero
        -:  692:            }
        -:  693:            else
        -:  694:            {
    #####:  695:                SPEX_CHECK(SPEX_mpz_sgn(&sgn, Lk_dense_col->x[ci]));
    #####:  696:                if (sgn != 0)
        -:  697:                {
        -:  698:                    // check if need to perform history update
    #####:  699:                    if (h[ci] != k-1)
        -:  700:                    {
    #####:  701:                        if (k > 0)
        -:  702:                        {
    #####:  703:                            SPEX_CHECK(SPEX_mpz_mul(Lk_dense_col->x[ci],
        -:  704:                                       Lk_dense_col->x[ci], sd[k-1]));
        -:  705:                        }
    #####:  706:                        SPEX_CHECK(SPEX_mpz_divexact(Lk_dense_col->x[ci],
        -:  707:                                   Lk_dense_col->x[ci], sd[h[ci]]));
        -:  708:                    }
    #####:  709:                    L->v[k]->i[pk] = ci;
    #####:  710:                    SPEX_CHECK(SPEX_mpz_swap(L->v[k]->x[pk],
        -:  711:                                             Lk_dense_col->x[ci]));
    #####:  712:                    pk++;
        -:  713:                }
        -:  714:            }
        -:  715:        }
        -:  716:        // update number of nnz in column k of L
    #####:  717:        L->v[k]->nz = pk;
        -:  718:    }
        -:  719:    // update S(1,k) and S(2,k) as 1, since all entry in L(:,k) are scaled
    #####:  720:    SPEX_CHECK(SPEX_mpq_set(SPEX_2D(S, 1, k), one));
    #####:  721:    SPEX_CHECK(SPEX_mpq_set(SPEX_2D(S, 3, k), one));
        -:  722:
        -:  723:    //-------------------------------------------------------------------------
        -:  724:    // RwSOP
        -:  725:    // NOTE: If explicit zero(s) from exact cancelllation of IPGE update are
        -:  726:    // kept, no fillin will be added.
        -:  727:    //-------------------------------------------------------------------------
        -:  728:    // pending_scale = U(k, Q(ks))/ U(k, Q(k))
    #####:  729:    SPEX_CHECK(SPEX_mpq_set_z(pending_scale, Uk_dense_row->x[Q[ks]]));
    #####:  730:    SPEX_CHECK(SPEX_mpq_set_den(pending_scale, Uk_dense_row->x[Q[k]]));
    #####:  731:    SPEX_CHECK(SPEX_mpq_canonicalize(pending_scale));
        -:  732:
        -:  733:    // iterate for all nnz in U(k+1:ks,Q(ks))
    #####:  734:    for (pks = Ucp_k_ks+1; pks < Ucp[Q[ks]+1]; pks++)
        -:  735:    {
    #####:  736:        i = Uci[pks];         // row index
        -:  737:
        -:  738:        // skip scaling for frames between iterations
        -:  739:        // REMARK: Uci[pks-1] must be at least equal to k
    #####:  740:        for (int64_t i1 = Uci[pks-1]+1; i1 < i; i1++)
        -:  741:        {
    #####:  742:            SPEX_CHECK(SPEX_mpq_mul(SPEX_2D(S, 3, i1),
        -:  743:                                    SPEX_2D(S, 3, i1), pending_scale));
    #####:  744:            SPEX_CHECK(SPEX_mpz_divexact(sd[i1], sd[i1],
        -:  745:                                    SPEX_MPQ_DEN(pending_scale)));
    #####:  746:            SPEX_CHECK(SPEX_mpz_mul(sd[i1], sd[i1],
        -:  747:                                    SPEX_MPQ_NUM(pending_scale)));
        -:  748:        }
        -:  749:
        -:  750:        // skip scaling if U(i, Q(ks)) == 0
    #####:  751:        SPEX_CHECK(SPEX_mpz_sgn(&sgn, U->v[i]->x[Ucx[pks]]));
    #####:  752:        if (sgn == 0)
        -:  753:        {
    #####:  754:            SPEX_CHECK(SPEX_mpq_mul(SPEX_2D(S, 3, i),
        -:  755:                                    SPEX_2D(S, 3, i), pending_scale));
    #####:  756:            SPEX_CHECK(SPEX_mpz_divexact(sd[i], sd[i],
        -:  757:                                    SPEX_MPQ_DEN(pending_scale)));
    #####:  758:            SPEX_CHECK(SPEX_mpz_mul(sd[i], sd[i],
        -:  759:                                    SPEX_MPQ_NUM(pending_scale)));
    #####:  760:            continue;
        -:  761:        }
        -:  762:
    #####:  763:        for (pi = 0; pi < U->v[i]->nz; pi++)
        -:  764:        {
    #####:  765:            ci = U->v[i]->i[pi];
        -:  766:            // handle U(i, Q[ks]) after iteration
    #####:  767:            if (ci == Q[ks]) { continue;}
    #####:  768:            else if (Q_inv[ci] < ks)
        -:  769:            {
        -:  770:                // apply pending_scale to U(i,Q(i:ks-1))
    #####:  771:                SPEX_CHECK(SPEX_mpz_divexact(U->v[i]->x[pi], U->v[i]->x[pi],
        -:  772:                                        SPEX_MPQ_DEN(pending_scale)));
    #####:  773:                SPEX_CHECK(SPEX_mpz_mul(U->v[i]->x[pi], U->v[i]->x[pi],
        -:  774:                                        SPEX_MPQ_NUM(pending_scale)));
        -:  775:                // set sd[i] = U(i, Q(i))
    #####:  776:                if (ci == Q[i])
        -:  777:                {
    #####:  778:                    SPEX_CHECK(SPEX_mpz_set(sd[i], U->v[i]->x[pi]));
        -:  779:                }
        -:  780:            }
        -:  781:            else
        -:  782:            {
        -:  783:                // perform RwSOP to U(i,Q(ks+1:n+1)), NO FILLIN
        -:  784:                // U(i,ci)= (U(i,ci)*U(k,Q(ks)) - U(i,Q(ks))*U(k,ci))/U(k,Q(k))
    #####:  785:                SPEX_CHECK(SPEX_mpz_mul(U->v[i]->x[pi], U->v[i]->x[pi],
        -:  786:                                        Uk_dense_row->x[Q[ks]]));
    #####:  787:                SPEX_CHECK(SPEX_mpz_submul(U->v[i]->x[pi], U->v[i]->x[Ucx[pks]],
        -:  788:                                        Uk_dense_row->x[ci]));
    #####:  789:                SPEX_CHECK(SPEX_mpz_divexact(U->v[i]->x[pi], U->v[i]->x[pi],
        -:  790:                                        Uk_dense_row->x[Q[k]]));
        -:  791:            }
        -:  792:        }
        -:  793:        // skip scaling for L(:,i) by setting S(1,i) = S(1,i)*pending_scale
    #####:  794:        pi = Ucx[pks];  // pointer for U(i,Q(ks))
    #####:  795:        if (i != ks)
        -:  796:        {
        -:  797:            // Mathematically, we should flip sign for U(i, Q(ks)). However,
        -:  798:            // since column ks of U will become column k after permutation,
        -:  799:            // which will be deleted when finished, we will instead delete
        -:  800:            // U(i,Q(ks)).
    #####:  801:            U->v[i]->nz--;
    #####:  802:            SPEX_CHECK(SPEX_mpz_swap(U->v[i]->x[pi], U->v[i]->x[U->v[i]->nz]));
        -:  803:            // S(1,i) = S(1,i)*pending_scale
    #####:  804:            SPEX_CHECK(SPEX_mpq_mul(SPEX_2D(S, 1, i),
        -:  805:                                    SPEX_2D(S, 1, i), pending_scale));
        -:  806:        }
        -:  807:        else
        -:  808:        {
    #####:  809:            SPEX_CHECK(SPEX_mpz_neg(U->v[i]->x[pi], U->v[i]->x[pi]));
    #####:  810:            SPEX_CHECK(SPEX_mpq_neg(SPEX_2D(S, 1, i), SPEX_2D(S, 1, i)));
    #####:  811:            SPEX_CHECK(SPEX_mpz_neg(sd[i], sd[i]));
        -:  812:        }
        -:  813:    }
        -:  814:
        -:  815:    //-------------------------------------------------------------------------
        -:  816:    // construct U(k,:) and copy U(ks,:) to Uk_dense_row
        -:  817:    //-------------------------------------------------------------------------
    #####:  818:    if (Uk_dense_row->nz-1 > U->v[k]->nzmax)
        -:  819:    {
    #####:  820:        SPEX_CHECK(SPEX_vector_realloc(U->v[k], Uk_dense_row->nz-1));
        -:  821:    }
    #####:  822:    U->v[k]->nz = 0;
    #####:  823:    for (pk = 0; pk < Uk_dense_row->nz; pk++)
        -:  824:    {
    #####:  825:        j = Uk_dense_row->i[pk];
    #####:  826:        if (j == Q[k]){ continue; } // no need to copy/reset/remove U(k,Q[k])
        -:  827:
    #####:  828:        SPEX_CHECK(SPEX_mpz_swap(U->v[k]->x[U->v[k]->nz], Uk_dense_row->x[j]));
    #####:  829:        U->v[k]->i[U->v[k]->nz] = j;
    #####:  830:        U->v[k]->nz++;
        -:  831:    }
        -:  832:
        -:  833:    // no need to do this when ks>=n-1
    #####:  834:    if (ks < n-1)
        -:  835:    {
        -:  836:        // construct a scattered vector for U->v[ks]
    #####:  837:        for (pks = 0; pks < U->v[ks]->nz; pks++)
        -:  838:        {
    #####:  839:            j = U->v[ks]->i[pks];
    #####:  840:            if (j == Q[ks])
        -:  841:            {
        -:  842:                // this entry should be considered as the IPGE update of the
        -:  843:                // entry in the Q[k]-th column
    #####:  844:                j = Q[k];
    #####:  845:                U->v[ks]->i[pks] = j;
        -:  846:            }
        -:  847:            else
        -:  848:            {
    #####:  849:                SPEX_CHECK(SPEX_mpz_sgn(&sgn, U->v[ks]->x[pks]));
    #####:  850:                if (sgn != 0 && Q_inv[j] < *jnext)
        -:  851:                {
    #####:  852:                    *jnext = Q_inv[j];
        -:  853:                }
        -:  854:            }
    #####:  855:            SPEX_CHECK(SPEX_mpz_swap(Uk_dense_row->x[j], U->v[ks]->x[pks]));
        -:  856:        }
        -:  857:    }
        -:  858:
        -:  859:    //-------------------------------------------------------------------------
        -:  860:    // update column permutation
        -:  861:    //-------------------------------------------------------------------------
        -:  862:    int64_t tmpi;
    #####:  863:    tmpi = Q[k];      Q[k] = Q[ks];          Q[ks] = tmpi;
    #####:  864:    Q_inv[Q[k]] = k;  Q_inv[Q[ks]] = ks;
        -:  865:
        -:  866:    //-------------------------------------------------------------------------
        -:  867:    // flip sign for columns and rows ks+1 to n and update corresponding sd
        -:  868:    //-------------------------------------------------------------------------
    #####:  869:    for (i = ks+1; i < n; i++)
        -:  870:    {
    #####:  871:        SPEX_CHECK(SPEX_mpq_neg(SPEX_2D(S, 3, i), SPEX_2D(S, 3, i)));
    #####:  872:        SPEX_CHECK(SPEX_mpz_neg(sd[i], sd[i]));
        -:  873:    }
        -:  874:
    #####:  875:    SPEX_FREE_ALL;
    #####:  876:    return SPEX_OK;
        -:  877:}
