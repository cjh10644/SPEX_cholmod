        -:    0:Source:spex_get_nnz_pattern.c
        -:    0:Graph:spex_get_nnz_pattern.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_CHOLMOD/spex_get_nnz_pattern.c: get the row-wise nonzero pattern of L
        -:    3:// and column-wise nonzero pattern of U.
        -:    4://------------------------------------------------------------------------------
        -:    5:
        -:    6:// SPEX_CHOLMOD: (c) 2020-2021, Jinhao Chen, Timothy A. Davis, Erick
        -:    7:// Moreno-Centeno, Texas A&M University.  All Rights Reserved.  See
        -:    8:// SPEX_CHOLMOD/License for the license.
        -:    9:
        -:   10://------------------------------------------------------------------------------
        -:   11:
        -:   12:// Purpose: This function finds the column-wise nonzero pattern from a
        -:   13:// compressed-row matrix U, and the column index of last off-diagonal entry in
        -:   14:// each row and the pointer to each diagonal entry of a compressed-column
        -:   15:// matrix L. 
        -:   16:
        -:   17:#define SPEXX_FREE_ALL                     \
        -:   18:    SPEX_FREE(rowcount);                   \
        -:   19:    SPEX_FREE(Ldiag_new);                  \
        -:   20:    SPEX_FREE(Lr_offdiag_new);             \
        -:   21:    SPEX_FREE(Ucp_new);                    \
        -:   22:    SPEX_FREE(Uci_new);                    \
        -:   23:    SPEX_FREE(Ucx_new);
        -:   24:
        -:   25:#define SPEX_FREE_WORK                     \
        -:   26:    SPEX_FREE(rowcount);
        -:   27:
        -:   28:#include "spex_internal.h"
        -:   29:
    #####:   30:SPEX_info spex_get_nnz_pattern    // find the nnz pattern of L and U
        -:   31:(
        -:   32:    // OUTPUT:
        -:   33:    int64_t **Ldiag,              // L(k,k) can be found as L->v[k]->x[Ldiag[k]]
        -:   34:    int64_t **Lr_offdiag,         // Lr_offdiag[k] gives the column index of the
        -:   35:                                  // last off-diagonal nnz in k-th row of L.
        -:   36:                                  // -1 if no off diagonal entry
        -:   37:    int64_t **Uci,                // the row index for col-wise nnz pattern of U
        -:   38:    int64_t **Ucp,                // col pointers for col-wise pattern of U
        -:   39:    int64_t **Ucx,                // find the value of k-th entry as
        -:   40:                                  // U->v[Uci[k]]->x[Ucx[k]]
        -:   41:    // INPUT:
        -:   42:    const SPEX_matrix *L,         // the target matrix L
        -:   43:    const SPEX_matrix *U,         // the target matrix U
        -:   44:    const int64_t *P,             // row permutation
        -:   45:    const SPEX_options *option    // command option
        -:   46:)
        -:   47:{
        -:   48:    // inputs are checked in SPEX_LUU
    #####:   49:    int64_t *Ldiag_new = NULL, *Lr_offdiag_new = NULL, *Ucp_new = NULL,
    #####:   50:            *Uci_new = NULL, *Ucx_new = NULL, *rowcount = NULL;
        -:   51:    int64_t i, j, p;
    #####:   52:    int64_t n = U->n;
        -:   53:
    #####:   54:    rowcount       = (int64_t*) SPEX_calloc( n,   sizeof(int64_t));
    #####:   55:    Ldiag_new      = (int64_t*) SPEX_malloc( n   *sizeof(int64_t));
    #####:   56:    Lr_offdiag_new = (int64_t*) SPEX_malloc( n   *sizeof(int64_t));
    #####:   57:    Ucp_new        = (int64_t*) SPEX_malloc((n+1)*sizeof(int64_t));
    #####:   58:    if (!rowcount || !Ldiag_new || !Lr_offdiag_new || !Ucp_new)
        -:   59:    {
        -:   60:        SPEX_FREE_ALL;
    #####:   61:        return SPEX_OUT_OF_MEMORY;
        -:   62:    }
        -:   63:
    #####:   64:    for (i = 0 ; i < n ; i++)
        -:   65:    {
    #####:   66:        Lr_offdiag_new[i] = -1;
        -:   67:    }
    #####:   68:    for (j = 0; j < n; j++)
        -:   69:    {
    #####:   70:        for (p = 0; p < L->v[j]->nz; p++)
        -:   71:        {
        -:   72:            // row index
    #####:   73:            i = L->v[j]->i[p];
        -:   74:
    #####:   75:            if (i == P[j])  // current entry is diagonal of L(P,:)
        -:   76:            {
    #####:   77:                Ldiag_new[j] = p; // get the row pointer
        -:   78:            }
        -:   79:            else            // get the last row-wise off-diagonal entries
        -:   80:            {
    #####:   81:                Lr_offdiag_new[i] = j; // get the column index
        -:   82:            }
        -:   83:        }
        -:   84:    }
        -:   85:
    #####:   86:    for (i = 0; i < n; i++)
        -:   87:    {
    #####:   88:        for (p = 0 ; p < U->v[i]->nz; p++)
        -:   89:        {
    #####:   90:            j = U->v[i]->i[p];
    #####:   91:            rowcount [j]++ ;
        -:   92:        }
        -:   93:    }
        -:   94:
        -:   95:    // compute cumulative sum of rowcount to get the row pointer
    #####:   96:    spex_cumsum(Ucp_new, rowcount, n);
        -:   97:
    #####:   98:    int64_t U_nnz = Ucp_new[n];
    #####:   99:    Uci_new = (int64_t*) SPEX_malloc(U_nnz*sizeof(int64_t));
    #####:  100:    Ucx_new = (int64_t*) SPEX_malloc(U_nnz*sizeof(int64_t));
    #####:  101:    if (!Uci_new || !Ucx_new)
        -:  102:    {
        -:  103:        SPEX_FREE_ALL;
    #####:  104:        return SPEX_OUT_OF_MEMORY;
        -:  105:    }
        -:  106:
    #####:  107:    for (i = 0 ; i < n ; i++)
        -:  108:    {
    #####:  109:        for (p = 0 ; p < U->v[i]->nz ; p++)
        -:  110:       {
    #####:  111:            j = U->v[i]->i[p];
    #####:  112:            Uci_new[ rowcount[j] ] = i ;
    #####:  113:            Ucx_new[ rowcount[j] ] = p ;
    #####:  114:            rowcount[j] ++;
        -:  115:        }
        -:  116:    }
        -:  117:
    #####:  118:    *Ldiag = Ldiag_new;
    #####:  119:    *Lr_offdiag = Lr_offdiag_new;
    #####:  120:    *Ucp = Ucp_new;
    #####:  121:    *Uci = Uci_new;
    #####:  122:    *Ucx = Ucx_new;
    #####:  123:    SPEX_FREE_WORK;
    #####:  124:    return SPEX_OK;
        -:  125:}
