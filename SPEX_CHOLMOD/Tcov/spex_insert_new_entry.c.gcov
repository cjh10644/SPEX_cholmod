        -:    0:Source:spex_insert_new_entry.c
        -:    0:Graph:spex_insert_new_entry.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_CHOLMOD/spex_insert_new_entry.c: insert an entry vi who has no pending
        -:    3:// scale to a scaled vector v1, find a common scale factor for v1 and vi and
        -:    4:// update (scale up) entries in v1 properly.
        -:    5://------------------------------------------------------------------------------
        -:    6:
        -:    7:// SPEX_CHOLMOD: (c) 2020-2021, Jinhao Chen, Timothy A. Davis, Erick
        -:    8:// Moreno-Centeno, Texas A&M University.  All Rights Reserved.  See
        -:    9:// SPEX_CHOLMOD/License for the license.
        -:   10:
        -:   11://------------------------------------------------------------------------------
        -:   12:
        -:   13:// Purpose: This function is call to insert vi as i-th entry of vector v1, which
        -:   14:// could be column of L or row of U in frame j. v1 and v2 together constitute
        -:   15:// frame j of the frame matrix. S1, S2 and S3 are correspondingly the pending
        -:   16:// scales for vector v1, vector v2, and all entries in frame j (If v1 is the
        -:   17:// j-th column of L, then S1, S2, S3 are scales for j-th column of L, j-th row
        -:   18:// of U and j-th frame of the frame matrix). Since vi has no pending scale
        -:   19:// factor and v1 has pending scale factor, we will find a new common factor for
        -:   20:// vi and v1, and properly scale v1 and vi before insert vi into v1.
        -:   21://
        -:   22:// NOTE: the value of vi is inserted by swapping with corresponding mpz_t value
        -:   23:// in v1, which should be considered as undefined after this function.
        -:   24:
        -:   25:#include "spex_internal.h"
        -:   26:
    #####:   27:SPEX_info spex_insert_new_entry
        -:   28:(
        -:   29:    mpz_t vi,          // the entry to be inserted as i-th entry of v1
        -:   30:    SPEX_vector *v1,   // the vector that would add new entry
        -:   31:    mpq_t S1,          // pending scale for v1
        -:   32:    const SPEX_vector *v2,// the other vector that is in same frame as v1
        -:   33:    mpq_t S2,          // pending scale for v2
        -:   34:    mpq_t S3,          // pending scale for frame that holds v1 and v2
        -:   35:    mpz_t d,           // the unscale pivot in frame of v1 and v2
        -:   36:    const int64_t i,   // the index of vi when inserted to v1
        -:   37:    const int64_t v2_diag,// the pointer to the diagonal entry in v2
        -:   38:    const mpq_t one    // a constant mpq number, just to avoid constantly alloc
        -:   39:)
        -:   40:{
        -:   41:    SPEX_info info;
        -:   42:    int r;
        -:   43:    int64_t p;
        -:   44:
        -:   45:    // d = v2(v2_diag) = d*S1
    #####:   46:    SPEX_CHECK(SPEX_mpz_set(d, v2->x[v2_diag]));
        -:   47:    // mpq_equal is said to be faster than mpq_cmq
    #####:   48:    SPEX_CHECK(SPEX_mpq_equal(&r, S3, one));
    #####:   49:    if (r == 0) // S3 != 1
        -:   50:    {
        -:   51:#if 0
        -:   52:        // find the gcd of inserted entry vi and numerator of scaling
        -:   53:        // factor for frame i
        -:   54:        SPEX_CHECK(SPEX_mpz_gcd(gcd, vi, SPEX_MPQ_NUM(S3)));
        -:   55:        SPEX_CHECK(SPEX_mpz_divexact(vi, vi, gcd));
        -:   56:        SPEX_CHECK(SPEX_mpz_divexact(SPEX_MPQ_NUM(S3), SPEX_MPQ_NUM(S3), gcd));
        -:   57:#endif
        -:   58:        // [S1;S2;S3] = [S1*S3; S2*S3; 1]
    #####:   59:        SPEX_CHECK(SPEX_mpq_mul(S1, S1, S3));
    #####:   60:        SPEX_CHECK(SPEX_mpq_mul(S2, S2, S3));
        -:   61:#if 0
        -:   62:        SPEX_CHECK(SPEX_mpq_set_z(S3, gcd));
        -:   63:#else
    #####:   64:        SPEX_CHECK(SPEX_mpq_set(S3, one));
        -:   65:#endif
        -:   66:    }
        -:   67:
    #####:   68:    SPEX_CHECK(SPEX_mpq_equal(&r, S1, one));
    #####:   69:    if (r == 0) //S1 != 1
        -:   70:    {
        -:   71:#if 0
        -:   72:        // find the gcd of inserted entry and numerator of S1
        -:   73:        SPEX_CHECK(SPEX_mpz_gcd(gcd, vi, SPEX_MPQ_NUM(S1)));
        -:   74:        SPEX_CHECK(SPEX_mpz_divexact(vi, vi, gcd));
        -:   75:        SPEX_CHECK(SPEX_mpz_divexact(SPEX_MPQ_NUM(S1), SPEX_MPQ_NUM(S1), gcd));
        -:   76:#endif
    #####:   77:        for (p = 0; p < v1->nz; p++)
        -:   78:        {
        -:   79:            // Since entries in v1 will be integer after scale, we can
        -:   80:            // perform division first to make it small, and this
        -:   81:            // division will preserve integer propety
    #####:   82:            SPEX_CHECK(SPEX_mpz_divexact(v1->x[p], v1->x[p],
        -:   83:                                       SPEX_MPQ_DEN(S1)));
    #####:   84:            SPEX_CHECK(SPEX_mpz_mul(v1->x[p], v1->x[p], SPEX_MPQ_NUM(S1)));
        -:   85:        }
        -:   86:#if 0
        -:   87:        SPEX_CHECK(SPEX_mpq_set_z(S1, gcd));
        -:   88:#else
    #####:   89:        SPEX_CHECK(SPEX_mpq_set(S1, one));
        -:   90:#endif
        -:   91:    }
        -:   92:    // append vi to v1
    #####:   93:    if (v1->nz == v1->nzmax)
        -:   94:    {
        -:   95:        // reallocate the nonzero pattern if needed
    #####:   96:        SPEX_CHECK(SPEX_vector_realloc(v1, 2*(v1->nzmax)));
        -:   97:    }
    #####:   98:    v1->i[v1->nz] = i;
    #####:   99:    SPEX_CHECK(SPEX_mpz_swap(v1->x[v1->nz], vi));
    #####:  100:    v1->nz ++;
        -:  101:
    #####:  102:    return SPEX_OK;
        -:  103:}
