        -:    0:Source:spex_get_scattered_v.c
        -:    0:Graph:spex_get_scattered_v.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_CHOLMOD/spex_get_scattered_v.c: build scattered vector for given sparse
        -:    3:// vector
        -:    4://------------------------------------------------------------------------------
        -:    5:
        -:    6:// SPEX_CHOLMOD: (c) 2020-2021, Jinhao Chen, Timothy A. Davis, Erick
        -:    7:// Moreno-Centeno, Texas A&M University.  All Rights Reserved.  See
        -:    8:// SPEX_CHOLMOD/License for the license.
        -:    9:
        -:   10://------------------------------------------------------------------------------
        -:   11:
        -:   12:// Purpose: This function is called to build scattered mpz vector for column or
        -:   13:// row k of A, or the inserted column. This function eliminates explicit
        -:   14:// 0 if specified. If keep_v is false, this function swap the mpz values, and
        -:   15:// thus the original vector will become all zeros. Otherwise, mpz_set will be
        -:   16:// used to keep the original mpz values.
        -:   17:
        -:   18:#define SPEX_FREE_ALL   \
        -:   19:    spex_scattered_vector_free(&sv);
        -:   20:
        -:   21:#include "spex_internal.h"
        -:   22:
    #####:   23:SPEX_info spex_get_scattered_v
        -:   24:(
        -:   25:    spex_scattered_vector **sv_handle,// output vector in scattered form
        -:   26:    SPEX_vector *v,              // the vector in compressed form, whose
        -:   27:                                 // max index is n
        -:   28:    const int64_t n,             // number of entries in v
        -:   29:    const bool eliminate_zero,   // indicate if explicit zero should be elimated
        -:   30:    const bool keep_v            // indicate if the mpz values should be kept
        -:   31:)
        -:   32:{
    #####:   33:    if (!sv_handle || !v)
        -:   34:    {
    #####:   35:        return SPEX_INCORRECT_INPUT;
        -:   36:    }
    #####:   37:    *sv_handle = NULL;
        -:   38:    SPEX_info info;
        -:   39:    int64_t p, i;
    #####:   40:    spex_scattered_vector *sv = NULL;
        -:   41:
    #####:   42:    SPEX_CHECK(spex_scattered_vector_alloc(&sv, n));
        -:   43:
        -:   44:    /* TODO combine spex_find_next_nz with this function?
        -:   45:    int sgn;
        -:   46:    p = 0;
        -:   47:    while (p < v->nz)
        -:   48:    {
        -:   49:        i = v->i[p];
        -:   50:        SPEX_CHECK(SPEX_mpz_sgn(&sgn, v->x[i]));
        -:   51:        if (sgn == 0 && eliminate_zero)
        -:   52:        {
        -:   53:            v->nz--;
        -:   54:            v->i[p] = v->i[v->nz];
        -:   55:        }
        -:   56:        else
        -:   57:        {
        -:   58:            if (sgn != 0 && k != perm_inv[i] && perm_inv[i] < inext)
        -:   59:            {
        -:   60:                inext = i;
        -:   61:            }
        -:   62:            if (keep_v)
        -:   63:            {
        -:   64:                SPEX_CHECK(SPEX_mpz_set(sv->x[i], v->x[i]));
        -:   65:            }
        -:   66:            else
        -:   67:            {
        -:   68:                SPEX_CHECK(SPEX_mpz_swap(sv->x[i], v->x[i]));
        -:   69:            }
        -:   70:            sv->i[p] = v->i[p];
        -:   71:            p++;
        -:   72:        }
        -:   73:    }
        -:   74:    sv->nz = v->nz;
        -:   75:    */
        -:   76:
    #####:   77:    if (eliminate_zero)
        -:   78:    {
        -:   79:        int sgn;
    #####:   80:        p = 0;
    #####:   81:        while (p < v->nz)
        -:   82:        {
    #####:   83:            SPEX_CHECK(SPEX_mpz_sgn(&sgn, v->x[p]));
    #####:   84:            if (sgn != 0)
        -:   85:            {
    #####:   86:                i = v->i[p];
    #####:   87:                if (keep_v)
        -:   88:                {
    #####:   89:                    SPEX_CHECK(SPEX_mpz_set(sv->x[i], v->x[p]));
        -:   90:                }
        -:   91:                else
        -:   92:                {
    #####:   93:                    SPEX_CHECK(SPEX_mpz_swap(sv->x[i], v->x[p]));
        -:   94:                }
    #####:   95:                sv->i[p] = v->i[p];
    #####:   96:                p++;
        -:   97:            }
        -:   98:            else
        -:   99:            {
    #####:  100:                v->nz--;
    #####:  101:                SPEX_CHECK(SPEX_mpz_swap(v->x[p], v->x[v->nz]));
    #####:  102:                v->i[p] = v->i[v->nz];
        -:  103:            }
        -:  104:        }
    #####:  105:        sv->nz = v->nz;
        -:  106:    }
        -:  107:    else
        -:  108:    {
    #####:  109:        for (p = 0; p < v->nz; p++)
        -:  110:        {
    #####:  111:            i = v->i[p];
    #####:  112:            if (keep_v)
        -:  113:            {
    #####:  114:                SPEX_CHECK(SPEX_mpz_set(sv->x[i], v->x[p]));
        -:  115:            }
        -:  116:            else
        -:  117:            {
    #####:  118:                SPEX_CHECK(SPEX_mpz_swap(sv->x[i], v->x[p]));
        -:  119:            }
    #####:  120:            sv->i[p] = v->i[p];
        -:  121:        }
    #####:  122:        sv->nz = v->nz;
        -:  123:    }
        -:  124:
    #####:  125:    *sv_handle = sv;
    #####:  126:    return SPEX_OK;
        -:  127:}
        -:  128:
