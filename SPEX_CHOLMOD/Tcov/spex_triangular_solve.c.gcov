        -:    0:Source:spex_triangular_solve.c
        -:    0:Graph:spex_triangular_solve.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_CHOLMOD/spex_triangular_solve.c: perform REF triangular solve up to
        -:    3:// specified iteration, additional history update for certain entries should
        -:    4:// be done after calling this function.
        -:    5://------------------------------------------------------------------------------
        -:    6:
        -:    7:// SPEX_CHOLMOD: (c) 2020-2021, Jinhao Chen, Timothy A. Davis, Erick
        -:    8:// Moreno-Centeno, Texas A&M University.  All Rights Reserved.  See
        -:    9:// SPEX_CHOLMOD/License for the license.
        -:   10:
        -:   11://------------------------------------------------------------------------------
        -:   12:
        -:   13:// Purpose: This function is to perform REF triangular solve for LDx=v up to
        -:   14:// specified IPGE iteration when both L and v are sparse. Additional history
        -:   15:// update should be done for certain entries based on the history vector. This
        -:   16:// function is used internally when computing the inserted column for U. For
        -:   17:// forward solving LDUx=b where b is mostly considered and stored as dense
        -:   18:// vector, we will use spex_forward_sub.
        -:   19:
        -:   20:#include "spex_internal.h"
        -:   21:
    #####:   22:SPEX_info spex_triangular_solve // perform REF triangular solve for LDx=v
        -:   23:(
        -:   24:    spex_scattered_vector *sv_x,// the scattered version of solution for LDx=v,
        -:   25:                        // using the first k-1 columns of L
        -:   26:    mpq_t x_scale,      // pending scale for x
        -:   27:    int64_t *h,         // history vector for x
        -:   28:    int64_t *last_update,// the number of finished IPGE iterations, which is
        -:   29:                        // also the number of columns in L used last time
        -:   30:    int64_t *i_2ndlast, // i_2ndlast is the index of the found last nnz entry
        -:   31:                        // of x[P] less than n, this could be NULL if not needed
        -:   32:    const int64_t k,    // compute x up to k-th IPGE iteration, that is, using
        -:   33:                        // the first k-1 columns of L
        -:   34:    const SPEX_matrix *L,// matrix L
        -:   35:    const int64_t *Ldiag,// L(k,k) can be found as L->v[k]->x[Ldiag[k]]
        -:   36:    const mpq_t *S,     // the pending scale factor matrix
        -:   37:    const mpz_t *sd,    // array of scaled pivots
        -:   38:    const int64_t *P,   // row permutation
        -:   39:    const int64_t *P_inv// inverse of row permutation
        -:   40:)
        -:   41:{
        -:   42:    SPEX_info info;
        -:   43:    int sgn;
    #####:   44:    if (!sv_x || !h || !last_update || !L || !S || !P || !P_inv || !sd)
        -:   45:    {
    #####:   46:        return SPEX_INCORRECT_INPUT;
        -:   47:    }
        -:   48:
    #####:   49:    if (*last_update < k-1)
        -:   50:    {
        -:   51:        // TODO iterate sorted nnz pattern?
    #####:   52:        for (int64_t j = *last_update+1; j < k; j++)
        -:   53:        {
        -:   54:            // skip if x(P[j]) == 0
    #####:   55:            SPEX_CHECK(SPEX_mpz_sgn(&sgn, sv_x->x[P[j]]));
    #####:   56:            if (sgn == 0)       { continue; }
        -:   57:
        -:   58:            // perform j-th IPGE update for x
    #####:   59:            SPEX_CHECK(spex_ipge(sv_x, x_scale, h, i_2ndlast, L->v[j], P,
        -:   60:                P_inv, sd, SPEX_2D(S, 1, j), SPEX_2D(S, 3, j), Ldiag[j], j));
        -:   61:        }
    #####:   62:        *last_update = k-1;
        -:   63:    }
        -:   64:
        -:   65:    // check if x[P[k]] is zero
    #####:   66:    SPEX_CHECK(SPEX_mpz_sgn(&sgn, sv_x->x[P[k]]));
    #####:   67:    if (sgn == 0)
        -:   68:    {
    #####:   69:        *last_update = k;
        -:   70:    }
        -:   71:
    #####:   72:    return SPEX_OK;
        -:   73:}
